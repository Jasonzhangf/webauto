import { app, BrowserWindow, ipcMain, nativeTheme, screen } from 'electron';
import path from 'node:path';
import fs from 'node:fs';
import { promises as fsPromises } from 'node:fs';
import os from 'node:os';
import { fileURLToPath } from 'node:url';
import { spawn, execSync } from 'node:child_process';
import { createRequire } from 'node:module';
import WebSocket, { WebSocketServer } from 'ws';
import { messageBus } from './messageBus.js';
import { ControllerClient } from './controllerClient.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const require = createRequire(import.meta.url);
const windowStateKeeper = require('electron-window-state');
const Positioner = require('electron-positioner');

const repoRoot = path.resolve(__dirname, '../../..');
const USER_CONTAINER_ROOT = path.join(os.homedir(), '.webauto', 'container-lib');
const CONTAINER_INDEX_PATH = path.join(repoRoot, 'container-library.index.json');
const NORMAL_SIZE = { width: 960, height: 640 };
const COLLAPSED_SIZE = { width: 180, height: 80 };
const DEFAULT_WS_HOST = process.env.WEBAUTO_WS_HOST || '127.0.0.1';
const DEFAULT_WS_PORT = Number(process.env.WEBAUTO_WS_PORT || 8765);
const DEFAULT_HTTP_HOST = process.env.WEBAUTO_BROWSER_HTTP_HOST || '127.0.0.1';
const DEFAULT_HTTP_PORT = Number(process.env.WEBAUTO_BROWSER_HTTP_PORT || 7704);
const DEFAULT_HTTP_PROTOCOL = process.env.WEBAUTO_BROWSER_HTTP_PROTO || 'http';
const AUTO_STICK_ENABLED = process.env.WEBAUTO_AUTO_STICK === '1';
const FLOATING_HEADLESS = process.env.WEBAUTO_FLOATING_HEADLESS === '0' ? false : true;
const BUS_BRIDGE_PORT = Number(process.env.WEBAUTO_FLOATING_BUS_PORT || 8790);
const CONTROLLER_HOST = process.env.WEBAUTO_CONTROLLER_HOST || '127.0.0.1';
const CONTROLLER_PORT = Number(process.env.WEBAUTO_CONTROLLER_PORT || 8970);
const CONTROLLER_ENDPOINT = process.env.WEBAUTO_CONTROLLER_URL || `ws://${CONTROLLER_HOST}:${CONTROLLER_PORT}`;
const CONTROLLER_AUTOSTART = process.env.WEBAUTO_CONTROLLER_AUTOSTART !== '0';
let headlessMode = FLOATING_HEADLESS;

const controllerClient = new ControllerClient({
  endpoint: CONTROLLER_ENDPOINT,
  repoRoot,
  messageBus,
  autoStart: CONTROLLER_AUTOSTART,
  spawnArgs: [`--host=${CONTROLLER_HOST}`, `--port=${CONTROLLER_PORT}`],
  spawnEnv: {
    WEBAUTO_USER_CONTAINER_ROOT: USER_CONTAINER_ROOT,
    WEBAUTO_CONTAINER_INDEX: CONTAINER_INDEX_PATH,
    WEBAUTO_BROWSER_HTTP_HOST: DEFAULT_HTTP_HOST,
    WEBAUTO_BROWSER_HTTP_PORT: String(DEFAULT_HTTP_PORT),
    WEBAUTO_BROWSER_HTTP_PROTO: DEFAULT_HTTP_PROTOCOL,
    WEBAUTO_WS_HOST: DEFAULT_WS_HOST,
    WEBAUTO_WS_PORT: String(DEFAULT_WS_PORT),
  },
  logger: console,
});
controllerClient.init();
const shutdownController = () => {
  controllerClient.dispose().catch(() => {});
};
app.on('will-quit', shutdownController);
process.on('exit', shutdownController);

// 健康检查管理器
class HealthMonitor {
  constructor() {
    this.wsConnected = false;
    this.controllerConnected = false;
    this.containerMatched = false;
    this.lastHealthCheck = Date.now();
    this.checkInterval = null;
    this.wsSocket = null;
    this.retryCount = 0;
    this.maxRetries = 3;
  }

  // 检查WebSocket连接状态
  async checkWSConnection() {
    return new Promise((resolve) => {
      try {
        const ws = new WebSocket(`ws://${DEFAULT_WS_HOST}:${DEFAULT_WS_PORT}`);
        const timeout = setTimeout(() => {
          try { ws.terminate(); } catch {}
          resolve(false);
        }, 3000);

        ws.on('open', () => {
          clearTimeout(timeout);
          try { ws.close(); } catch {}
          resolve(true);
        });

        ws.on('error', () => {
          clearTimeout(timeout);
          resolve(false);
        });

        ws.on('close', () => {
          clearTimeout(timeout);
          resolve(false);
        });
      } catch (err) {
        resolve(false);
      }
    });
  }

  // 检查控制器连接状态
  async checkControllerConnection() {
    return controllerClient.isConnected();
  }

  // 测试容器匹配能力
  async testContainerMatching() {
    if (!this.wsConnected) {
      return { success: false, message: 'WebSocket未连接' };
    }

    return new Promise((resolve) => {
      try {
        const ws = new WebSocket(`ws://${DEFAULT_WS_HOST}:${DEFAULT_WS_PORT}`);
        const timeout = setTimeout(() => {
          try { ws.terminate(); } catch {}
          resolve({ success: false, message: '测试超时' });
        }, 5000);

        const messageHandler = (data) => {
          try {
            const response = JSON.parse(data.toString());
            
            if (response.type === 'response' ||
                response.type === 'container_match_result' || 
                response.type === 'match_result' ||
                response.data?.type === 'container_match') {
              clearTimeout(timeout);
              ws.removeListener('message', messageHandler);
              
              const result = response.data || response;
              if (result && result.success !== undefined) {
                if (result.success) {
                  resolve({ success: true, message: result.message || '容器匹配测试成功' });
                } else {
                  // 容器操作失败可能是正常的（没有实际会话），但命令格式正确
                  if (result.error && result.error.includes('Session')) {
                    resolve({ success: true, message: 'WebSocket服务正常响应容器操作命令（需要创建会话）' });
                  } else {
                    resolve({ success: false, message: result.error || '容器操作失败' });
                  }
                }
              } else {
                resolve({ success: true, message: 'WebSocket服务响应容器操作命令' });
              }
            } else if (response.type === 'error') {
              clearTimeout(timeout);
              ws.removeListener('message', messageHandler);
              resolve({ success: false, message: response.message || '命令格式错误' });
            }
          } catch {
            // 继续等待
          }
        };

        ws.on('message', messageHandler);
        ws.on('error', () => {
          clearTimeout(timeout);
          resolve({ success: false, message: 'WebSocket连接错误' });
        });

        // 发送测试命令
        const testRequest = {
          type: 'command',
          session_id: 'health-check',
          data: {
            command_type: 'container_operation',
            action: 'match_root',
            page_context: {
              url: 'https://weibo.com',
              timestamp: Date.now(),
              test_mode: true
            }
          }
        };

        ws.send(JSON.stringify(testRequest));
      } catch (err) {
        resolve({ success: false, message: `测试异常: ${err.message}` });
      }
    });
  }

  // 执行完整健康检查
  async performHealthCheck() {
    console.log('[HealthMonitor] 开始健康检查...');
    
    const report = {
      timestamp: new Date().toISOString(),
      ws: { connected: false, latency: 0 },
      controller: { connected: false },
      container: { matched: false, message: '' }
    };

    // 检查WebSocket
    const wsStart = Date.now();
    const wsHealthy = await this.checkWSConnection();
    const wsLatency = Date.now() - wsStart;
    report.ws.connected = wsHealthy;
    report.ws.latency = wsLatency;
    this.wsConnected = wsHealthy;

    // 检查控制器
    const controllerHealthy = await this.checkControllerConnection();
    report.controller.connected = controllerHealthy;
    this.controllerConnected = controllerHealthy;

    // 测试容器匹配
    if (wsHealthy) {
      const matchResult = await this.testContainerMatching();
      report.container.matched = matchResult.success;
      report.container.message = matchResult.message;
      this.containerMatched = matchResult.success;
    } else {
      report.container.message = 'WebSocket未连接，无法测试容器匹配';
    }

    this.lastHealthCheck = Date.now();

    // 广播健康状态
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('health:report', report);
    }
    messageBus.publish('health.report', report);

    // 记录结果
    if (wsHealthy && controllerHealthy) {
      console.log('[HealthMonitor] ✅ 系统健康', report);
      this.retryCount = 0; // 重置重试计数
    } else {
      console.warn('[HealthMonitor] ❌ 系统异常', report);
      this.retryCount++;
      
      // 如果重试次数过多，发出严重警告
      if (this.retryCount >= this.maxRetries) {
        const errorMsg = `[HealthMonitor] 严重错误: WS=${wsHealthy}, Controller=${controllerHealthy}, 重试次数=${this.retryCount}`;
        console.error(errorMsg);
        
        // 发送错误通知
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('health:error', {
            message: '系统连接异常，请检查服务状态',
            details: report,
            timestamp: new Date().toISOString()
          });
        }
        messageBus.publish('health.error', {
          message: '系统连接异常，请检查服务状态',
          details: report
        });
      }
    }

    return report;
  }

  // 启动定期健康检查
  start(intervalMs = 10000) {
    console.log(`[HealthMonitor] 启动定期健康检查，间隔: ${intervalMs}ms`);
    
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }

    // 立即执行一次
    this.performHealthCheck().catch(err => {
      console.error('[HealthMonitor] 初始健康检查失败:', err.message);
    });

    // 定期检查
    this.checkInterval = setInterval(async () => {
      try {
        await this.performHealthCheck();
      } catch (err) {
        console.error('[HealthMonitor] 定期健康检查失败:', err.message);
      }
    }, intervalMs);
  }

  // 停止健康检查
  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    if (this.wsSocket) {
      try { this.wsSocket.close(); } catch {}
      this.wsSocket = null;
    }
    console.log('[HealthMonitor] 健康检查已停止');
  }

  // 获取当前状态
  getStatus() {
    return {
      wsConnected: this.wsConnected,
      controllerConnected: this.controllerConnected,
      containerMatched: this.containerMatched,
      lastCheck: this.lastHealthCheck,
      uptime: Date.now() - this.lastHealthCheck
    };
  }

  // 尝试重连
  async attemptReconnect() {
    console.log('[HealthMonitor] 尝试重连...');
    
    for (let i = 0; i < this.maxRetries; i++) {
      const result = await this.performHealthCheck();
      if (result.ws.connected && result.controller.connected) {
        console.log('[HealthMonitor] 重连成功');
        this.retryCount = 0;
        return true;
      }
      await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
    }
    
    console.error('[HealthMonitor] 重连失败');
    return false;
  }
}

// 初始化健康检查器
const healthMonitor = new HealthMonitor();
healthMonitor.start(10000); // 每10秒检查一次

// 注册健康检查相关的Bus处理器
function registerHealthHandlers() {
  messageBus.subscribe('health.request', async () => {
    const report = await healthMonitor.performHealthCheck();
    messageBus.publish('health.response', report);
  });

  messageBus.subscribe('health.status', () => {
    const status = healthMonitor.getStatus();
    messageBus.publish('health.status.response', status);
  });

  messageBus.subscribe('health.reconnect', async () => {
    const success = await healthMonitor.attemptReconnect();
    messageBus.publish('health.reconnect.response', { success });
  });
}

registerHealthHandlers();

// 在应用退出时清理
const shutdownHealthMonitor = () => {
  healthMonitor.stop();
};
app.on('will-quit', shutdownHealthMonitor);
process.on('exit', shutdownHealthMonitor);

let mainWindow;
let positioner;
let isCollapsed = false;
let lastNormalBounds = null;
let inspectorWindow = null;
let inspectorReady = false;
let inspectorPendingPayload = null;
let inspectorContext = null;
let inspectorBusy = false;
let autoStickScheduled = false;
let busBridge;
const busClients = new Set();

registerBusHandlers();

messageBus.on('__broadcast__', (event) => {
  broadcastBusEvent(event);
});

function broadcastBusEvent(event) {
  const targets = [mainWindow, inspectorWindow].filter((win) => win && !win.isDestroyed());
  targets.forEach((win) => {
    try {
      win.webContents.send('bus:event', event);
    } catch (err) {
      console.warn('[bus] failed to forward event', err?.message || err);
    }
  });
  if (busClients.size) {
    const payload = JSON.stringify({ topic: event.topic, payload: event.payload });
    busClients.forEach((socket) => {
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(payload);
      }
    });
  }
}

function registerBusHandlers() {
  const topics = [
    ['ui.window.shrinkToBall', () => toggleCollapse(true)],
    ['ui.window.restoreFromBall', () => toggleCollapse(false)],
    [
      'ui.window.toggleHeadless',
      (payload = {}) => {
        if (typeof payload?.headless === 'boolean') {
          applyHeadlessMode(payload.headless);
        } else {
          applyHeadlessMode(!headlessMode);
        }
      },
    ],
    [
      'ui.window.setHeadless',
      (payload = {}) => {
        if (typeof payload?.headless === 'boolean') {
          applyHeadlessMode(payload.headless);
        }
      },
    ],
    ['ui.ball.doubleClick', () => toggleCollapse(false)],
    [
      'ui.window.stickToBrowser',
      async (payload = {}) => {
        await handleStickBrowser(payload || {});
      },
    ],
    ['ui.window.requestState', () => publishWindowState()],
    ["dom:highlight_request", async (payload = {}) => {
      await controllerClient.call("highlight_element", { selector: payload.selector, options: { persistent: payload.persistent, channel: payload.channel } });
    }],
    ["dom:highlight_cleared", async (payload = {}) => {
      await controllerClient.call("clear_highlight", { channel: payload.channel });
    }]
  ];
  topics.forEach(([topic, handler]) => {
    messageBus.subscribe(topic, async (payload) => {
      try {
        await handler(payload);
      } catch (err) {
        console.warn(`[bus] handler for ${topic} failed`, err);
        messageBus.publish('ui.window.error', { topic, message: err?.message || String(err) });
      }
    });
  });
}

function startBusBridge() {
  if (!BUS_BRIDGE_PORT || busBridge) {
    return;
  }
  try {
    busBridge = new WebSocketServer({ port: BUS_BRIDGE_PORT, host: '127.0.0.1' });
  } catch (err) {
    console.warn('[bus] bridge start failed', err?.message || err);
    return;
  }
  busBridge.on('connection', (socket) => {
    busClients.add(socket);
    socket.on('message', (raw) => {
      try {
        const payload = JSON.parse(raw.toString());
        if (payload?.topic) {
          messageBus.publish(payload.topic, payload.payload);
        }
      } catch (err) {
        console.warn('[bus] invalid client message', err?.message || err);
      }
    });
    socket.on('close', () => busClients.delete(socket));
    socket.on('error', () => busClients.delete(socket));
  });
  busBridge.on('listening', () => {
    console.log(`[bus] bridge listening on ws://127.0.0.1:${BUS_BRIDGE_PORT}`);
  });
  busBridge.on('error', (err) => {
    console.warn('[bus] bridge error', err?.message || err);
  });
}

const gotLock = app.requestSingleInstanceLock();
if (!gotLock) {
  app.quit();
  process.exit(0);
} else {
  if (process.env.ELECTRON_ENABLE_LOGGING === '1') {
    app.commandLine.appendSwitch('enable-logging');
  }
  app.on('second-instance', () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });
}

startBusBridge();

const createWindow = () => {
  const windowState = windowStateKeeper({
    defaultWidth: NORMAL_SIZE.width,
    defaultHeight: NORMAL_SIZE.height,
  });

  const desiredWidth = Math.max(windowState.width || NORMAL_SIZE.width, NORMAL_SIZE.width);
  const desiredHeight = Math.max(windowState.height || NORMAL_SIZE.height, NORMAL_SIZE.height);

  console.log('[floating] windowState:', { x: windowState.x, y: windowState.y, width: desiredWidth, height: desiredHeight });

  mainWindow = new BrowserWindow({
    x: windowState.x,
    y: windowState.y,
    width: desiredWidth,
    height: desiredHeight,
    minWidth: Math.max(520, Math.floor(NORMAL_SIZE.width * 0.4)),
    minHeight: 360,
    frame: false,
    transparent: !FLOATING_HEADLESS,
    resizable: true,
    maximizable: false,
    fullscreenable: false,
    backgroundColor: FLOATING_HEADLESS ? '#050711' : '#050711d0',
    show: !FLOATING_HEADLESS,
    alwaysOnTop: !FLOATING_HEADLESS,
    skipTaskbar: false,
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      sandbox: false,
    },
  });

  positioner = new Positioner(mainWindow);
  if (windowState.x === undefined || windowState.y === undefined) {
    positioner.move('rightCenter');
  }

  windowState.manage(mainWindow);
  lastNormalBounds = mainWindow.getBounds();
  if (!FLOATING_HEADLESS) {
    console.log('[floating] 设置窗口可见在所有工作空间');
    mainWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
  } else {
    console.log('[floating] 设置窗口为headless模式');
    mainWindow.setIgnoreMouseEvents(true, { forward: true });
  }
  console.log('[floating] 窗口创建完成，FLOATING_HEADLESS:', FLOATING_HEADLESS, 'show:', !FLOATING_HEADLESS);
  const rendererPath = path.resolve(__dirname, '../renderer/index.html');
  mainWindow.loadFile(rendererPath);
  mainWindow.webContents.on('console-message', (_event, level, message, line, sourceId) => {
    console.log(`[renderer][${level}] ${message} (${sourceId}:${line})`);
  });
  mainWindow.webContents.session.webRequest.onErrorOccurred((details) => {
    if (!details?.url?.includes('app.js') && !details?.url?.includes('/renderer/')) return;
    console.warn('[renderer] resource load error', details.url, details.error);
  });
  mainWindow.webContents.on('dom-ready', () => {
    mainWindow.webContents
      .executeJavaScript(
        'console.log("[floating] scripts", Array.from(document.scripts).map(s => s.src || "inline"));',
      )
      .catch((err) => console.warn('[floating] dom-ready eval failed', err));
  });
  mainWindow.webContents.on('did-finish-load', () => {
    console.log('[floating] did-finish-load event triggered');
    broadcastCollapseState();
    if (!FLOATING_HEADLESS) {
      console.log('[floating] did-finish-load scheduling auto-stick');
      scheduleAutoStick();
    }
  });

  mainWindow.on('ready-to-show', () => {
    console.log('[floating] ready-to-show event triggered');
    
    // 强制显示窗口（即使没有AUTO_STICK_ENABLED）
    if (!FLOATING_HEADLESS) {
      console.log('[floating] forcing window to visible state');
      mainWindow.show();
      mainWindow.focus();
      mainWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
      
      // 使用positioner设置到右侧
      if (positioner) {
        positioner.move('rightCenter');
        console.log('[floating] moved to rightCenter via positioner');
      }
    }
    
    enforceWorkAreaBounds();
    snapToEdges();
    
    if (FLOATING_HEADLESS) {
      console.log('[floating] headless window ready');
    }
    broadcastHeadlessState();
  });

  let snapTimer;
  mainWindow.on('move', () => {
    clearTimeout(snapTimer);
    enforceWorkAreaBounds();
    snapTimer = setTimeout(() => {
      enforceWorkAreaBounds();
      snapToEdges();
    }, 140);
  });

  mainWindow.on('resize', () => {
    if (!isCollapsed && mainWindow && !mainWindow.isMaximized()) {
      lastNormalBounds = mainWindow.getBounds();
    }
  });

  mainWindow.on('maximize', () => {
    if (!mainWindow) return;
    mainWindow.unmaximize();
    restoreNormalBounds();
    snapToEdges();
  });

  mainWindow.on('enter-full-screen', () => {
    mainWindow?.setFullScreen(false);
    restoreNormalBounds();
    snapToEdges();
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};

function restoreNormalBounds() {
  if (!mainWindow) return;
  const target = lastNormalBounds || { ...NORMAL_SIZE, x: undefined, y: undefined };
  const bounds = mainWindow.getBounds();
  mainWindow.setBounds(
    {
      x: bounds.x,
      y: bounds.y,
      width: target.width || NORMAL_SIZE.width,
      height: target.height || NORMAL_SIZE.height,
    },
    false,
  );
  mainWindow.setResizable(true);
  isCollapsed = false;
}

function snapToEdges() {
  if (!mainWindow) return;
  const bounds = mainWindow.getBounds();
  const display = screen.getDisplayMatching(bounds);
  if (!display) return;
  const area = display.workArea;
  const threshold = 40;
  let { x, y } = bounds;
  if (Math.abs(bounds.x - area.x) < threshold) {
    x = area.x;
  } else if (Math.abs(bounds.x + bounds.width - (area.x + area.width)) < threshold) {
    x = area.x + area.width - bounds.width;
  }
  if (Math.abs(bounds.y - area.y) < threshold) {
    y = area.y;
  } else if (Math.abs(bounds.y + bounds.height - (area.y + area.height)) < threshold) {
    y = area.y + area.height - bounds.height;
  }
  if (x !== bounds.x || y !== bounds.y) {
    mainWindow.setBounds({ ...bounds, x: Math.round(x), y: Math.round(y) }, false);
  }
}

function scheduleAutoStick(delay = 800) {
  if (!AUTO_STICK_ENABLED || FLOATING_HEADLESS || autoStickScheduled || process.platform !== 'darwin') {
    return;
  }
  autoStickScheduled = true;
  setTimeout(() => {
    alignWithFrontmostBrowser().catch((err) => {
      console.warn('[floating] auto stick failed:', err?.message || err);
    });
  }, delay);
}

async function alignWithFrontmostBrowser() {
  console.log('[floating] alignWithFrontmostBrowser called');
  const display = screen.getPrimaryDisplay();
  const area = display?.workArea || screen.getPrimaryDisplay().workArea;
  console.log('[floating] display area:', area);
  const browserWidth = Math.round(area.width * 0.72);
  const spacer = 12;
  const floatWidth = Math.round(area.width * 0.28) - spacer;
  const floatHeight = Math.min(NORMAL_SIZE.height, area.height - spacer * 2);
  const floatX = area.x + browserWidth + spacer;
  const floatY = area.y + spacer;
  console.log('[floating] float window position:', { x: floatX, y: floatY, width: floatWidth, height: floatHeight });

  try {
    await resizeFrontmostWindow({
      x: area.x,
      y: area.y,
      width: browserWidth,
      height: area.height,
    });
    console.log('[floating] resizeFrontmostWindow succeeded');
  } catch (err) {
    console.warn('[floating] resizeFrontmostWindow failed:', err?.message || err);
  }

  if (mainWindow) {
    mainWindow.setBounds(
      {
        x: floatX,
        y: floatY,
        width: floatWidth,
        height: floatHeight,
      },
      false,
    );
    console.log('[floating] mainWindow.setBounds called');
    lastNormalBounds = mainWindow.getBounds();
    snapToEdges();
    mainWindow.focus();
    console.log('[floating] alignWithFrontmostBrowser completed');
  } else {
    console.warn('[floating] mainWindow is null in alignWithFrontmostBrowser');
  }
}

function enforceWorkAreaBounds() {
  if (!mainWindow) return;
  const bounds = mainWindow.getBounds();
  const display = screen.getDisplayMatching(bounds);
  if (!display) return;
  const area = display.workArea;
  const maxX = area.x + area.width - bounds.width;
  const maxY = area.y + area.height - bounds.height;
  const clampedX = Math.min(Math.max(bounds.x, area.x), maxX);
  const clampedY = Math.min(Math.max(bounds.y, area.y), maxY);
  if (clampedX !== bounds.x || clampedY !== bounds.y) {
    mainWindow.setBounds({ ...bounds, x: Math.round(clampedX), y: Math.round(clampedY) }, false);
  }
}

function publishWindowState() {
  broadcastCollapseState();
  broadcastHeadlessState();
}

function broadcastCollapseState() {
  if (mainWindow) {
    mainWindow.webContents.send('window:collapse-state', { isCollapsed });
  }
  messageBus.publish('ui.window.stateChanged', { collapsed: isCollapsed, mode: isCollapsed ? 'ball' : 'normal' });
}

function broadcastHeadlessState() {
  if (mainWindow) {
    mainWindow.webContents.send('window:headless-state', { headless: headlessMode });
  }
  messageBus.publish('ui.window.headlessChanged', { headless: headlessMode });
}

function applyHeadlessMode(enabled) {
  headlessMode = Boolean(enabled);
  if (!mainWindow) return;
  if (headlessMode) {
    mainWindow.hide();
    mainWindow.setIgnoreMouseEvents(true, { forward: true });
  } else {
    mainWindow.setIgnoreMouseEvents(false);
    mainWindow.show();
    mainWindow.focus();
    mainWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
    scheduleAutoStick();
  }
  broadcastHeadlessState();
}

function toggleCollapse(nextState) {
  if (!mainWindow) return;
  const targetState = typeof nextState === 'boolean' ? nextState : !isCollapsed;
  isCollapsed = targetState;
  const bounds = mainWindow.getBounds();
  if (isCollapsed) {
    mainWindow.setBounds(
      {
        x: bounds.x,
        y: bounds.y,
        width: COLLAPSED_SIZE.width,
        height: COLLAPSED_SIZE.height,
      },
      false,
    );
    mainWindow.setResizable(false);
  } else {
    const width = lastNormalBounds?.width || NORMAL_SIZE.width;
    const height = lastNormalBounds?.height || NORMAL_SIZE.height;
    mainWindow.setBounds(
      {
        x: bounds.x,
        y: bounds.y,
        width,
        height,
      },
      false,
    );
    mainWindow.setResizable(true);
    lastNormalBounds = mainWindow.getBounds();
  }
  enforceWorkAreaBounds();
  snapToEdges();
  broadcastCollapseState();
}

function fitWindowHeight(contentHeight) {
  if (!mainWindow || isCollapsed) return;
  const numeric = Number(contentHeight);
  if (!Number.isFinite(numeric) || numeric <= 0) return;
  const bounds = mainWindow.getBounds();
  const display = screen.getDisplayMatching(bounds) || screen.getPrimaryDisplay();
  const area = display?.workArea || screen.getPrimaryDisplay().workArea;
  const padding = 20;
  const minHeight = NORMAL_SIZE.height;
  const maxHeight = Math.max(minHeight, area.height - 30);
  const targetHeight = Math.max(Math.min(Math.round(numeric + padding), maxHeight), minHeight);
  if (Math.abs(targetHeight - bounds.height) < 4) return;
  let targetY = bounds.y;
  const bottomEdge = targetY + targetHeight;
  const maxBottom = area.y + area.height;
  if (bottomEdge > maxBottom) {
    targetY = Math.max(area.y, maxBottom - targetHeight);
  }
  mainWindow.setBounds(
    {
      x: bounds.x,
      y: targetY,
      width: bounds.width,
      height: targetHeight,
    },
    false,
  );
  lastNormalBounds = mainWindow.getBounds();
  snapToEdges();
}

app.whenReady().then(() => {
  nativeTheme.themeSource = 'dark';
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

ipcMain.on('window-control', (_event, rawAction) => {
  if (!mainWindow) return;
  const payload =
    typeof rawAction === 'string'
      ? { action: rawAction }
      : rawAction && typeof rawAction === 'object'
        ? rawAction
        : { action: undefined };
  console.log('[window-control]', payload);
  const { action, value } = payload;
  switch (action) {
    case 'close':
      mainWindow.close();
      break;
    case 'minimize':
      mainWindow.minimize();
      break;
    case 'toggle-collapse':
      toggleCollapse(typeof value === 'boolean' ? value : undefined);
      break;
    case 'set-headless':
      applyHeadlessMode(typeof value === 'boolean' ? value : !headlessMode);
      break;
    case 'publish':
      if (payload?.topic) {
        messageBus.publish(payload.topic, payload.payload);
      }
      break;
    default:
      break;
  }
});

ipcMain.on('bus:publish', (_event, payload = {}) => {
  if (!payload?.topic) return;
  messageBus.publish(payload.topic, payload.payload);
});

ipcMain.on('ui:log', (_event, payload = {}) => {
  const level = payload.level;
  const args = Array.isArray(payload.args) ? payload.args : [payload.args];
  const prefix = '[floating-ui]';
  switch (level) {
    case 'warn':
      console.warn(prefix, ...args);
      break;
    case 'error':
      console.error(prefix, ...args);
      break;
    default:
      console.log(prefix, ...args);
      break;
  }
});

ipcMain.handle('inspector:open', async (_event, payload = {}) => {
  const profile = payload.profile;
  if (!profile) {
    throw new Error('缺少 profile');
  }
  const context = await controllerClient.captureSnapshot({
    profile,
    url: payload.url,
    maxDepth: payload.maxDepth,
    maxChildren: payload.maxChildren,
  });
  inspectorContext = { profile: context.profileId, url: context.targetUrl };
  await ensureInspectorWindow();
  pushInspectorSnapshot(context);
  if (inspectorWindow) {
    inspectorWindow.show();
    inspectorWindow.focus();
  }
  return { success: true };
});

ipcMain.on('inspector:ready', (event) => {
  if (!inspectorWindow || event.sender !== inspectorWindow.webContents) {
    return;
  }
  inspectorReady = true;
  if (inspectorPendingPayload) {
    inspectorWindow.webContents.send('inspector:data', inspectorPendingPayload);
  }
});

ipcMain.on('inspector:command', async (_event, command = {}) => {
  if (!command?.type) return;
  switch (command.type) {
    case 'refresh':
      if (inspectorBusy) {
        sendInspectorEvent({ type: 'toast', data: { message: '正在刷新，请稍候' } });
        return;
      }
      if (!inspectorContext?.profile && !command.profile) {
        sendInspectorEvent({ type: 'error', error: '缺少 profile，无法刷新' });
        return;
      }
      inspectorBusy = true;
      try {
        const context = await controllerClient.captureSnapshot({
          profile: command.profile || inspectorContext?.profile || inspectorPendingPayload?.profileId,
          url: command.url || inspectorContext?.url || inspectorPendingPayload?.targetUrl,
          maxDepth: command.maxDepth,
          maxChildren: command.maxChildren,
        });
        inspectorContext = { profile: context.profileId, url: context.targetUrl };
        pushInspectorSnapshot(context);
        sendInspectorEvent({ type: 'toast', data: { message: '容器视图已刷新' } });
      } catch (err) {
        sendInspectorEvent({ type: 'error', error: err?.message || '刷新失败' });
      } finally {
        inspectorBusy = false;
      }
      break;
    case 'update-selector':
    case 'create-child':
      sendInspectorEvent({ type: 'error', error: '容器编辑功能尚未开放' });
      break;
    default:
      sendInspectorEvent({ type: 'error', error: `Unsupported container action: ${command.type}` });
      break;
  }
});

ipcMain.on('window:fit-height', (_event, payload) => {
  const height = typeof payload === 'number' ? payload : payload?.height;
  fitWindowHeight(height);
});

ipcMain.handle('ui:action', async (_event, request) => {
  const action = request?.action;
  const payload = request?.payload || {};
  if (!action) {
    return { success: false, error: 'Missing action' };
  }
  if (action === 'window:stick-browser') {
    try {
      return await handleStickBrowser(payload);
    } catch (err) {
      return { success: false, error: err?.message || String(err) };
    }
  }
  try {
    return await controllerClient.call(action, payload);
  } catch (err) {
    return { success: false, error: err?.message || String(err) };
  }
});



async function handleStickBrowser(payload = {}) {
  if (!mainWindow) return { success: false, error: 'no main window' };
  
  // 进入紧凑模式：缩小为一个小条
  const compactBar = { 
    width: 200,  // 小条宽度
    height: 40,  // 小条高度
    x: 0,        // 贴左边
    y: 0         // 贴上边
  };
  
  // 获取屏幕工作区域
  const display = screen.getDisplayMatching(mainWindow.getBounds());
  const area = display?.workArea || screen.getPrimaryDisplay().workArea;
  
  // 设置贴边位置（左上角）
  compactBar.x = area.x;
  compactBar.y = area.y;
  
  // 应用紧凑尺寸
  mainWindow.setBounds(compactBar, false);
  
  // 确保窗口可见且在最前
  mainWindow.setAlwaysOnTop(true, 'floating');
  mainWindow.show();
  mainWindow.focus();
  
  // 设置鼠标hover事件监听
  setupHoverToRestore(compactBar);
  
  return { success: true };
}

function setupHoverToRestore(originalBounds) {
  if (!mainWindow) return;
  
  // 清除之前的监听器
  if (mainWindow._hoverTimer) {
    clearTimeout(mainWindow._hoverTimer);
  }
  
  // 鼠标进入事件：恢复窗口
  mainWindow.on('enter', () => {
    if (mainWindow._hoverTimer) {
      clearTimeout(mainWindow._hoverTimer);
    }
    
    // 恢复到正常大小
    const normalSize = { 
      width: NORMAL_SIZE.width, 
      height: NORMAL_SIZE.height 
    };
    
    // 确保在屏幕范围内
    const display = screen.getDisplayMatching(mainWindow.getBounds());
    const area = display?.workArea || screen.getPrimaryDisplay().workArea;
    
    let newX = mainWindow.getBounds().x;
    let newY = mainWindow.getBounds().y;
    
    // 调整位置确保不超出屏幕
    if (newX + normalSize.width > area.x + area.width) {
      newX = area.x + area.width - normalSize.width;
    }
    if (newY + normalSize.height > area.y + area.height) {
      newY = area.y + area.height - normalSize.height;
    }
    
    mainWindow.setBounds({
      x: newX,
      y: newY,
      width: normalSize.width,
      height: normalSize.height
    }, false);
  });
  
  // 鼠标离开事件：延迟恢复小条
  mainWindow.on('leave', () => {
    mainWindow._hoverTimer = setTimeout(() => {
      if (!mainWindow) return;
      mainWindow.setBounds(originalBounds, false);
    }, 500); // 500ms延迟，避免频繁切换
  });
}

async function resizeFrontmostWindow(bounds) {
  if (process.platform !== 'darwin') {
    throw new Error('浏览器贴边目前仅支持 macOS');
  }
  const script = `
tell application "System Events"
  set frontProc to first process whose frontmost is true
  tell frontProc
    if (count of windows) > 0 then
      set position of window 1 to {${bounds.x}, ${bounds.y}}
      set size of window 1 to {${bounds.width}, ${bounds.height}}
    end if
  end tell
end tell`;
  execSync(`osascript -e ${JSON.stringify(script)}`);
}

async function ensureInspectorWindow() {
  if (inspectorWindow && !inspectorWindow.isDestroyed()) {
    return inspectorWindow;
  }
  inspectorWindow = new BrowserWindow({
    width: 960,
    height: 620,
    minWidth: 520,
    minHeight: 400,
    title: 'WebAuto 容器视图',
    autoHideMenuBar: true,
    show: true,
    backgroundColor: '#050711',
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      sandbox: false,
    },
  });
  inspectorReady = false;
  inspectorPendingPayload = null;
  const inspectorPath = path.resolve(__dirname, '../renderer/inspector.html');
  inspectorWindow.loadFile(inspectorPath);
  inspectorWindow.on('closed', () => {
    inspectorWindow = null;
    inspectorReady = false;
    inspectorPendingPayload = null;
    inspectorContext = null;
    inspectorBusy = false;
  });
  return inspectorWindow;
}

function pushInspectorSnapshot(context) {
  inspectorPendingPayload = formatInspectorPayload(context);
  if (inspectorWindow && inspectorReady && inspectorPendingPayload) {
    inspectorWindow.webContents.send('inspector:data', inspectorPendingPayload);
  }
}

function sendInspectorEvent(event) {
  if (inspectorWindow && inspectorReady) {
    inspectorWindow.webContents.send('inspector:event', event);
  }
}

function formatInspectorPayload(context) {
  if (!context) return null;
  return {
    sessionId: context.sessionId,
    profileId: context.profileId,
    targetUrl: context.targetUrl,
    snapshot: context.snapshot,
  };
}
