# å°çº¢ä¹¦MCPé›†æˆè®¾è®¡ä¸å®ç°æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

åŸºäºå¯¹xiaohongshu-mcpé¡¹ç›®çš„æ·±å…¥åˆ†æï¼Œç»“åˆstagehandçš„æ™ºèƒ½è§‚å¯Ÿæ¨¡å¼å’ŒCamoufoxçš„æµè§ˆå™¨è‡ªåŠ¨åŒ–èƒ½åŠ›ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ã€æ™ºèƒ½åŒ–çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–åŠ©æ‰‹æ¨¡å—ã€‚è¯¥æ¨¡å—å°†æ”¯æŒå¤æ‚çš„ç¤¾äº¤åª’ä½“è‡ªåŠ¨åŒ–æ“ä½œï¼Œç‰¹åˆ«æ˜¯å°çº¢ä¹¦ç­‰å¹³å°çš„å†…å®¹äº¤äº’ã€‚

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ

### 1. **æ™ºèƒ½è‡ªåŠ¨åŒ–æ¨¡å¼**
- **Stagehandæ¨¡å¼**: åŸºäºå¯è®¿é—®æ€§æ ‘çš„æ™ºèƒ½å…ƒç´ è¯†åˆ«
- **xiaohongshu-mcpæ¨¡å¼**: é’ˆå¯¹ç‰¹å®šå¹³å°çš„ä¼˜åŒ–äº¤äº’ç­–ç•¥
- **Camoufoxä¼˜åŠ¿**: åæŒ‡çº¹æ£€æµ‹å’Œå®Œæ•´Playwright APIæ”¯æŒ

### 2. **æ¨¡å—åŒ–æ¶æ„**
- æ¯ä¸ªæ“ä½œç‹¬ç«‹å°è£…ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
- æ”¯æŒå¤šç§æµè§ˆå™¨è‡ªåŠ¨åŒ–ç­–ç•¥
- æä¾›ç»Ÿä¸€çš„æ¥å£å’Œé”™è¯¯å¤„ç†æœºåˆ¶

### 3. **AIé©±åŠ¨åˆ†æ**
- é›†æˆLLMè¿›è¡Œé¡µé¢ç†è§£å’Œæ“ä½œå»ºè®®
- æ™ºèƒ½å…ƒç´ è¯†åˆ«å’Œåˆ†ç±»
- åŠ¨æ€å†…å®¹å¤„ç†å’ŒçŠ¶æ€ç®¡ç†

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Browser Assistant Module                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ¯ Application Layer                                       â”‚
â”‚  â”œâ”€â”€ XiaohongshuActions (å°çº¢ä¹¦ä¸“ç”¨æ“ä½œ)                    â”‚
â”‚  â”œâ”€â”€ SocialMediaActions (é€šç”¨ç¤¾äº¤åª’ä½“æ“ä½œ)                  â”‚
â”‚  â””â”€â”€ UniversalActions (é€šç”¨æµè§ˆå™¨æ“ä½œ)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ§  Intelligence Layer                                      â”‚
â”‚  â”œâ”€â”€ PageAnalyzer (é¡µé¢åˆ†æå™¨)                             â”‚
â”‚  â”œâ”€â”€ AIAssistant (AIæ“ä½œå»ºè®®)                              â”‚
â”‚  â””â”€â”€ ContentExtractor (æ™ºèƒ½å†…å®¹æå–)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ® Operations Layer                                        â”‚
â”‚  â”œâ”€â”€ PageOperationCenter (é¡µé¢æ“ä½œä¸­å¿ƒ)                      â”‚
â”‚  â”œâ”€â”€ ElementSelector (æ™ºèƒ½å…ƒç´ é€‰æ‹©å™¨)                       â”‚
â”‚  â””â”€â”€ InteractionEngine (äº¤äº’å¼•æ“)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸŒ Browser Management Layer                                â”‚
â”‚  â”œâ”€â”€ CamoufoxManager (Camoufoxæµè§ˆå™¨ç®¡ç†)                   â”‚
â”‚  â”œâ”€â”€ CookieManager (Cookieç®¡ç†å™¨)                           â”‚
â”‚  â””â”€â”€ WebSocketServer (å®æ—¶æ§åˆ¶æ¥å£)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”§ Infrastructure Layer                                     â”‚
â”‚  â”œâ”€â”€ BaseModule (RCCåŸºç¡€æ¨¡å—)                              â”‚
â”‚  â”œâ”€â”€ ErrorHandler (é”™è¯¯å¤„ç†å™¨)                              â”‚
â”‚  â””â”€â”€ UnderConstruction (æœªå®ŒæˆåŠŸèƒ½ç®¡ç†)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ è¯¦ç»†ç»„ä»¶è®¾è®¡

### 1. **Application Layer - åº”ç”¨å±‚**

#### 1.1 XiaohongshuActions (å°çº¢ä¹¦ä¸“ç”¨æ“ä½œ)

```typescript
// src/actions/XiaohongshuActions.ts
export class XiaohongshuActions extends BaseSocialMediaActions {
  private readonly baseUrl = 'https://www.xiaohongshu.com';
  
  constructor(
    browserManager: CamoufoxManager,
    operationCenter: PageOperationCenter,
    aiAssistant: AIAssistant
  ) {
    super(browserManager, operationCenter, aiAssistant);
  }

  /**
   * æ£€æŸ¥ç™»å½•çŠ¶æ€ - åŸºäºxiaohongshu-mcpæ¨¡å¼
   */
  async checkLoginStatus(): Promise<LoginStatus> {
    const page = await this.browserManager.getCurrentPage();
    
    // æ™ºèƒ½æ£€æµ‹å¤šç§ç™»å½•çŠ¶æ€æŒ‡ç¤ºå™¨
    const loginSelectors = [
      '.main-container .user .link-wrapper .channel',
      '.user-info .avatar',
      '.header .user-menu'
    ];

    for (const selector of loginSelectors) {
      const exists = await page.$(selector);
      if (exists) {
        return { isLoggedIn: true, indicator: selector };
      }
    }

    return { isLoggedIn: false };
  }

  /**
   * ç™»å½•æ“ä½œ - å¤šç­–ç•¥å®ç°
   */
  async login(credentials: LoginCredentials): Promise<LoginResult> {
    const page = await this.browserManager.getCurrentPage();
    
    // å¯¼èˆªåˆ°ç™»å½•é¡µé¢
    await page.goto(`${this.baseUrl}/login`);
    
    // æ™ºèƒ½ç­‰å¾…ç™»å½•è¡¨å•åŠ è½½
    await this.waitForLoginForm(page);
    
    // å¤šç­–ç•¥ç™»å½•è¡¨å•å¤„ç†
    const loginStrategies = [
      () => this.loginWithUsernamePassword(page, credentials),
      () => this.loginWithQRCode(page),
      () => this.loginWithMobile(page, credentials)
    ];

    for (const strategy of loginStrategies) {
      try {
        const result = await strategy();
        if (result.success) {
          return result;
        }
      } catch (error) {
        this.logger.warn(`Login strategy failed: ${error.message}`);
      }
    }

    throw new Error('All login strategies failed');
  }

  /**
   * å‘å¸ƒå†…å®¹ - åŸºäºxiaohongshu-mcpçš„å®Œæ•´å®ç°
   */
  async publishContent(content: PublishContent): Promise<PublishResult> {
    const page = await this.browserManager.getCurrentPage();
    
    // 1. å¯¼èˆªåˆ°å‘å¸ƒé¡µé¢
    await page.goto(`${this.baseUrl}/publisher`);
    await this.waitForPublisherReady(page);
    
    // 2. æ™ºèƒ½å†…å®¹è¾“å…¥ - æ”¯æŒå¤šç§ç¼–è¾‘å™¨ç±»å‹
    await this.inputContent(page, content);
    
    // 3. å›¾ç‰‡ä¸Šä¼  - å¤šç§ä¸Šä¼ ç­–ç•¥
    if (content.images?.length) {
      await this.uploadImages(page, content.images);
    }
    
    // 4. æ ‡ç­¾å¤„ç†
    if (content.tags?.length) {
      await this.addTags(page, content.tags);
    }
    
    // 5. å‘å¸ƒæ“ä½œ
    return await this.submitPublish(page);
  }

  /**
   * è·å–ç¬”è®°åˆ—è¡¨ - æ™ºèƒ½å†…å®¹æå–
   */
  async getNotesList(options: NotesListOptions): Promise<NotesListResult> {
    const page = await this.browserManager.getCurrentPage();
    
    // æ„å»ºæœç´¢æˆ–ä¸»é¡µURL
    const url = this.buildNotesListUrl(options);
    await page.goto(url);
    
    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    await this.waitForNotesLoaded(page);
    
    // æ™ºèƒ½æå–ç¬”è®°æ•°æ®
    return await this.extractNotesData(page, options);
  }

  /**
   * æå–å•ç¯‡ç¬”è®°è¯¦æƒ…
   */
  async extractNoteDetails(noteUrl: string): Promise<NoteDetails> {
    const page = await this.browserManager.getCurrentPage();
    await page.goto(noteUrl);
    
    // ç­‰å¾…ç¬”è®°è¯¦æƒ…é¡µé¢åŠ è½½
    await this.waitForNoteDetails(page);
    
    // å¤šå±‚æ¬¡å†…å®¹æå–
    return {
      basicInfo: await this.extractBasicInfo(page),
      content: await this.extractNoteContent(page),
      author: await this.extractAuthorInfo(page),
      images: await this.extractImages(page),
      comments: await this.extractComments(page),
      relatedNotes: await this.extractRelatedNotes(page)
    };
  }

  // ç§æœ‰æ–¹æ³•å®ç°...
}
```

#### 1.2 SocialMediaActions (é€šç”¨ç¤¾äº¤åª’ä½“æ“ä½œ)

```typescript
// src/actions/SocialMediaActions.ts
export abstract class SocialMediaActions extends BaseBrowserModule {
  protected browserManager: CamoufoxManager;
  protected operationCenter: PageOperationCenter;
  protected aiAssistant: AIAssistant;

  constructor(
    browserManager: CamoufoxManager,
    operationCenter: PageOperationCenter,
    aiAssistant: AIAssistant
  ) {
    super('SocialMediaActions');
    this.browserManager = browserManager;
    this.operationCenter = operationCenter;
    this.aiAssistant = aiAssistant;
  }

  /**
   * é€šç”¨é¡µé¢ç±»å‹åˆ†æ
   */
  async analyzePageType(): Promise<PageAnalysisResult> {
    const page = await this.browserManager.getCurrentPage();
    
    // ä½¿ç”¨AIåˆ†æå™¨è¿›è¡Œé¡µé¢ç±»å‹è¯†åˆ«
    const analysis = await this.aiAssistant.analyzePageStructure(page);
    
    // éªŒè¯å’Œè¡¥å……åˆ†æç»“æœ
    const validated = await this.validatePageAnalysis(analysis);
    
    return validated;
  }

  /**
   * æ™ºèƒ½æ»šåŠ¨å’Œå†…å®¹åŠ è½½
   */
  async smartScrollForContent(options: SmartScrollOptions): Promise<ScrollResult> {
    const page = await this.browserManager.getCurrentPage();
    
    let previousHeight = 0;
    let scrollAttempts = 0;
    const maxAttempts = options.maxAttempts || 10;
    let loadedItems: any[] = [];

    while (scrollAttempts < maxAttempts) {
      // æ»šåŠ¨é¡µé¢
      await this.operationCenter.scroll(page, {
        amount: options.scrollAmount || 1000,
        direction: 'down',
        smooth: true
      });

      // ç­‰å¾…æ–°å†…å®¹åŠ è½½
      await this.sleep(options.waitTime || 2000);

      // æ£€æŸ¥é¡µé¢é«˜åº¦å˜åŒ–
      const currentHeight = await page.evaluate(() => document.body.scrollHeight);
      
      if (currentHeight === previousHeight) {
        // é¡µé¢é«˜åº¦æœªå˜åŒ–ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ–°å†…å®¹
        const newItems = await this.detectNewContent(page, loadedItems);
        if (newItems.length === 0) {
          break; // æ²¡æœ‰æ–°å†…å®¹ï¼Œç»“æŸæ»šåŠ¨
        }
        loadedItems = [...loadedItems, ...newItems];
      } else {
        previousHeight = currentHeight;
      }

      scrollAttempts++;
    }

    return {
      scrollCount: scrollAttempts,
      totalItems: loadedItems.length,
      hasMoreContent: scrollAttempts < maxAttempts
    };
  }

  /**
   * æ™ºèƒ½å†…å®¹æå– - åŸºäºé¡µé¢ç±»å‹
   */
  async extractContentByPageType(pageType: PageType): Promise<ContentExtractionResult> {
    const page = await this.browserManager.getCurrentPage();
    
    switch (pageType) {
      case 'single-column-infinite':
        return await this.extractSingleColumnContent(page);
      case 'single-column-paginated':
        return await this.extractPaginatedContent(page);
      case 'grid-infinite':
        return await this.extractGridContent(page);
      case 'grid-paginated':
        return await this.extractGridPaginatedContent(page);
      default:
        return await this.extractGenericContent(page);
    }
  }

  // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»éœ€è¦å®ç°
  abstract checkLoginStatus(): Promise<any>;
  abstract login(credentials: any): Promise<any>;
  abstract publishContent(content: any): Promise<any>;
}
```

### 2. **Intelligence Layer - æ™ºèƒ½å±‚**

#### 2.1 AIAssistant (AIæ“ä½œå»ºè®®)

```typescript
// src/intelligence/AIAssistant.ts
export class AIAssistant extends BaseBrowserModule {
  private llmClient: any; // LLMå®¢æˆ·ç«¯
  private promptTemplates: Map<string, string>;

  constructor(llmClient?: any) {
    super('AIAssistant');
    this.llmClient = llmClient;
    this.initializePromptTemplates();
  }

  /**
   * é¡µé¢ç»“æ„åˆ†æ
   */
  async analyzePageStructure(page: Page): Promise<PageAnalysis> {
    // è·å–é¡µé¢å¯è®¿é—®æ€§æ ‘
    const accessibilityTree = await page.accessibility.snapshot();
    
    // è·å–é¡µé¢DOMç»“æ„
    const domStructure = await this.extractDOMStructure(page);
    
    // æ„å»ºåˆ†ææç¤º
    const prompt = this.buildAnalysisPrompt(accessibilityTree, domStructure);
    
    // è°ƒç”¨AIè¿›è¡Œåˆ†æ
    const analysis = await this.callLLM(prompt, {
      schema: PageAnalysisSchema
    });
    
    return analysis;
  }

  /**
   * æ™ºèƒ½å…ƒç´ è¯†åˆ«
   */
  async identifyElements(page: Page, context: ElementContext): Promise<ElementIdentification[]> {
    const screenshot = await page.screenshot();
    const accessibilityTree = await page.accessibility.snapshot();
    
    const prompt = this.buildElementIdentificationPrompt(
      screenshot, accessibilityTree, context
    );
    
    return await this.callLLM(prompt, {
      schema: ElementIdentificationSchema
    });
  }

  /**
   * æ“ä½œå»ºè®®ç”Ÿæˆ
   */
  async suggestOperations(page: Page, goal: string): Promise<OperationSuggestion[]> {
    const currentState = await this.getCurrentPageState(page);
    
    const prompt = this.buildOperationSuggestionPrompt(currentState, goal);
    
    return await this.callLLM(prompt, {
      schema: OperationSuggestionSchema
    });
  }

  // ç§æœ‰æ–¹æ³•...
}
```

#### 2.2 PageAnalyzer (é¡µé¢åˆ†æå™¨)

```typescript
// src/intelligence/PageAnalyzer.ts
export class PageAnalyzer extends BaseBrowserModule {
  private aiAssistant: AIAssistant;

  constructor(aiAssistant: AIAssistant) {
    super('PageAnalyzer');
    this.aiAssistant = aiAssistant;
  }

  /**
   * é¡µé¢å¸ƒå±€ç±»å‹åˆ†æ
   */
  async analyzeLayoutType(page: Page): Promise<LayoutAnalysis> {
    // è·å–é¡µé¢ä¸»è¦å®¹å™¨
    const containers = await this.extractMainContainers(page);
    
    // åˆ†æå¸ƒå±€æ¨¡å¼
    const layoutPattern = await this.analyzeLayoutPattern(containers);
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºæ— é™æ»šåŠ¨æˆ–åˆ†é¡µ
    const scrollType = await this.detectScrollType(page);
    
    // åˆ†æç½‘æ ¼æˆ–å•åˆ—å¸ƒå±€
    const gridType = await this.analyzeGridType(containers);
    
    return {
      layout: layoutPattern,
      scrollType,
      gridType,
      containers: containers.map(c => ({
        selector: c.selector,
        elementCount: c.elementCount,
        repeatPattern: c.repeatPattern
      }))
    };
  }

  /**
   * ä¸»å¸–å­åˆ—è¡¨åˆ†æ
   */
  async analyzePostListStructure(page: Page): Promise<PostListAnalysis> {
    // ä½¿ç”¨AIåˆ†æå¸–å­åˆ—è¡¨ç»“æ„
    const aiAnalysis = await this.aiAssistant.analyzePageStructure(page);
    
    // éªŒè¯å’Œæå–å¸–å­å®¹å™¨
    const postContainer = await this.findPostContainer(page, aiAnalysis);
    
    // åˆ†æå¸–å­å…ƒç´ æ¨¡å¼
    const postPattern = await this.analyzePostElements(page, postContainer);
    
    return {
      containerSelector: postContainer.selector,
      postSelector: postPattern.selector,
      postElements: postPattern.elements,
      repeatPattern: postPattern.repeatPattern
    };
  }

  /**
   * å¯è§†å…ƒç´ åˆ†æ
   */
  async analyzeVisibleElements(page: Page): Promise<VisibleElementsAnalysis> {
    // è·å–å¯è§†åŒºåŸŸå†…çš„å…ƒç´ 
    const visibleElements = await this.getVisibleElements(page);
    
    // åˆ†æé‡å¤æ¨¡å¼
    const repeatedElements = await this.analyzeRepeatingElements(visibleElements);
    
    // æ‰¾å‡ºæœ€å¤§é¢ç§¯çš„å…ƒç´ 
    const largestElements = await this.findLargestElements(visibleElements);
    
    return {
      totalElements: visibleElements.length,
      mostRepeated: repeatedElements,
      largestByArea: largestElements,
      patterns: await this.analyzeElementPatterns(visibleElements)
    };
  }
}
```

### 3. **Operations Layer - æ“ä½œå±‚**

æˆ‘ä»¬å·²ç»å®ç°äº†å®Œæ•´çš„PageOperationCenterï¼Œç°åœ¨éœ€è¦æ·»åŠ æ™ºèƒ½å…ƒç´ é€‰æ‹©å™¨ã€‚

#### 3.1 SmartElementSelector (æ™ºèƒ½å…ƒç´ é€‰æ‹©å™¨)

```typescript
// src/operations/SmartElementSelector.ts
export class SmartElementSelector extends BaseBrowserModule {
  private aiAssistant: AIAssistant;
  private fallbackStrategies: Map<string, SelectorStrategy[]>;

  constructor(aiAssistant: AIAssistant) {
    super('SmartElementSelector');
    this.aiAssistant = aiAssistant;
    this.initializeFallbackStrategies();
  }

  /**
   * æ™ºèƒ½å…ƒç´ é€‰æ‹© - å¤šç­–ç•¥å®ç°
   */
  async selectElement(page: Page, context: ElementContext): Promise<ElementSelection> {
    // ç­–ç•¥1: AIæ™ºèƒ½è¯†åˆ«
    try {
      const aiSelection = await this.selectWithAI(page, context);
      if (aiSelection.confidence > 0.8) {
        return aiSelection;
      }
    } catch (error) {
      this.logger.warn('AI selection failed, trying fallback strategies');
    }

    // ç­–ç•¥2: ä¼ ç»ŸCSSé€‰æ‹©å™¨
    const cssSelection = await this.selectWithCSS(page, context);
    if (cssSelection.found) {
      return cssSelection;
    }

    // ç­–ç•¥3: å±æ€§é€‰æ‹©å™¨
    const attrSelection = await this.selectWithAttributes(page, context);
    if (attrSelection.found) {
      return attrSelection;
    }

    // ç­–ç•¥4: æ–‡æœ¬å†…å®¹åŒ¹é…
    const textSelection = await this.selectWithText(page, context);
    if (textSelection.found) {
      return textSelection;
    }

    throw new ElementNotFoundError(`Cannot find element for context: ${JSON.stringify(context)}`);
  }

  /**
   * åŸºäºAIçš„å…ƒç´ é€‰æ‹©
   */
  private async selectWithAI(page: Page, context: ElementContext): Promise<ElementSelection> {
    const screenshot = await page.screenshot();
    const accessibilityTree = await page.accessibility.snapshot();
    
    const identifications = await this.aiAssistant.identifyElements(page, {
      screenshot,
      accessibilityTree,
      context
    });

    // é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„å…ƒç´ 
    const bestMatch = identifications.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );

    return {
      element: await page.$(bestMatch.selector),
      selector: bestMatch.selector,
      confidence: bestMatch.confidence,
      method: 'ai'
    };
  }

  /**
   * ç«äº‰å¼å…ƒç´ é€‰æ‹© - åŸºäºxiaohongshu-mcpæ¨¡å¼
   */
  async raceElementSelection(page: Page, selectors: string[]): Promise<ElementSelection> {
    const timeout = 5000; // 5ç§’è¶…æ—¶
    
    return Promise.race(
      selectors.map(async (selector) => {
        try {
          const element = await page.waitForSelector(selector, { timeout });
          return {
            element,
            selector,
            confidence: 0.9,
            method: 'race'
          };
        } catch {
          throw new Error(`Selector ${selector} not found`);
        }
      })
    );
  }
}
```

### 4. **Browser Management Layer - æµè§ˆå™¨ç®¡ç†å±‚**

#### 4.1 CamoufoxManager (Camoufoxæµè§ˆå™¨ç®¡ç†å™¨)

```typescript
// src/browser/CamoufoxManager.ts
export class CamoufoxManager extends BaseBrowserModule {
  private browser: CamoufoxBrowser | null = null;
  private context: CamoufoxContext | null = null;
  private page: Page | null = null;
  private cookieManager: CookieManager;
  private config: CamoufoxConfig;

  constructor(config: CamoufoxConfig = {}) {
    super('CamoufoxManager');
    this.config = { ...defaultConfig, ...config };
    this.cookieManager = new CookieManager();
  }

  /**
   * åˆå§‹åŒ–æµè§ˆå™¨ - åŸºäºxiaohongshu-mcpæ¨¡å¼
   */
  async initialize(): Promise<void> {
    await super.initialize();
    
    // å¯åŠ¨Camoufoxæµè§ˆå™¨
    this.browser = await camoufox.launch({
      headless: this.config.headless,
      args: this.config.browserArgs,
      ignoreDefaultArgs: ['--disable-extensions'],
      timeout: this.config.launchTimeout
    });

    // åˆ›å»ºæµè§ˆå™¨ä¸Šä¸‹æ–‡
    this.context = await this.browser.newContext({
      viewport: this.config.viewport,
      userAgent: this.config.userAgent,
      ignoreHTTPSErrors: true
    });

    // åˆ›å»ºæ–°é¡µé¢
    this.page = await this.context.newPage();
    
    // è®¾ç½®é¡µé¢è¶…æ—¶
    this.page.setDefaultTimeout(this.config.defaultTimeout);
    
    // åŠ è½½Cookie
    await this.cookieManager.loadCookies(this.context);

    this.logger.info('Camoufox browser initialized successfully');
  }

  /**
   * è·å–å½“å‰é¡µé¢
   */
  async getCurrentPage(): Promise<Page> {
    if (!this.page) {
      throw new Error('Browser not initialized. Call initialize() first.');
    }
    return this.page;
  }

  /**
   * åˆ›å»ºæ–°é¡µé¢å®ä¾‹ - åŸºäºxiaohongshu-mcpçš„fresh instanceæ¨¡å¼
   */
  async createFreshPage(): Promise<Page> {
    if (!this.context) {
      throw new Error('Browser context not initialized');
    }
    
    const newPage = await this.context.newPage();
    newPage.setDefaultTimeout(this.config.defaultTimeout);
    
    return newPage;
  }

  /**
   * é‡å¯æµè§ˆå™¨
   */
  async restart(): Promise<void> {
    await this.cleanup();
    await this.initialize();
  }

  /**
   * æ¸…ç†èµ„æº
   */
  async cleanup(): Promise<void> {
    if (this.page) {
      await this.page.close();
      this.page = null;
    }
    
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
    
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
    
    await super.cleanup();
  }
}
```

#### 4.2 CookieManager (Cookieç®¡ç†å™¨)

```typescript
// src/browser/CookieManager.ts
export class CookieManager extends BaseBrowserModule {
  private cookieStorage: Map<string, CookieData[]>;
  private encryptionKey: string;

  constructor(encryptionKey?: string) {
    super('CookieManager');
    this.cookieStorage = new Map();
    this.encryptionKey = encryptionKey || 'default-key';
  }

  /**
   * åŠ è½½Cookie - æŒ‰åŸŸå
   */
  async loadCookies(context: CamoufoxContext, domain?: string): Promise<void> {
    if (domain) {
      const cookies = await this.loadDomainCookies(domain);
      if (cookies.length > 0) {
        await context.addCookies(cookies);
        this.logger.info(`Loaded ${cookies.length} cookies for domain: ${domain}`);
      }
    } else {
      // åŠ è½½æ‰€æœ‰Cookie
      for (const [domain, cookies] of this.cookieStorage) {
        if (cookies.length > 0) {
          await context.addCookies(cookies);
        }
      }
    }
  }

  /**
   * ä¿å­˜Cookie - æŒ‰åŸŸååˆ†ç±»
   */
  async saveCookies(page: Page): Promise<void> {
    const cookies = await page.context().cookies();
    
    // æŒ‰åŸŸååˆ†ç»„
    const domainGroups = this.groupCookiesByDomain(cookies);
    
    // åŠ å¯†å¹¶ä¿å­˜
    for (const [domain, domainCookies] of domainGroups) {
      const encrypted = await this.encryptCookies(domainCookies);
      this.cookieStorage.set(domain, encrypted);
      
      // æŒä¹…åŒ–åˆ°æ–‡ä»¶ç³»ç»Ÿ
      await this.persistCookies(domain, encrypted);
    }
    
    this.logger.info(`Saved cookies for ${domainGroups.size} domains`);
  }

  /**
   * æ¸…é™¤æŒ‡å®šåŸŸåçš„Cookie
   */
  async clearDomainCookies(domain: string): Promise<void> {
    this.cookieStorage.delete(domain);
    await this.removePersistedCookies(domain);
    this.logger.info(`Cleared cookies for domain: ${domain}`);
  }
}
```

## ğŸ¯ æ ¸å¿ƒä½¿ç”¨åœºæ™¯

### 1. **å°çº¢ä¹¦è‡ªåŠ¨åŒ–æ“ä½œ**

```typescript
// ä½¿ç”¨ç¤ºä¾‹
async function xiaohongshuAutomationExample() {
  // 1. åˆå§‹åŒ–ç»„ä»¶
  const browserManager = new CamoufoxManager({ headless: false });
  const operationCenter = new PageOperationCenter();
  const aiAssistant = new AIAssistant();
  const xiaohongshuActions = new XiaohongshuActions(
    browserManager, 
    operationCenter, 
    aiAssistant
  );

  // 2. åˆå§‹åŒ–æµè§ˆå™¨
  await browserManager.initialize();

  try {
    // 3. æ£€æŸ¥ç™»å½•çŠ¶æ€
    const loginStatus = await xiaohongshuActions.checkLoginStatus();
    
    if (!loginStatus.isLoggedIn) {
      // 4. æ‰§è¡Œç™»å½•
      const loginResult = await xiaohongshuActions.login({
        username: 'your_username',
        password: 'your_password'
      });
      console.log('Login result:', loginResult);
    }

    // 5. å‘å¸ƒå†…å®¹
    const publishResult = await xiaohongshuActions.publishContent({
      title: 'æµ‹è¯•ç¬”è®°æ ‡é¢˜',
      content: 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•ç¬”è®°å†…å®¹',
      images: ['/path/to/image1.jpg', '/path/to/image2.jpg'],
      tags: ['æµ‹è¯•', 'è‡ªåŠ¨åŒ–']
    });

    console.log('Publish result:', publishResult);

    // 6. è·å–ç¬”è®°åˆ—è¡¨
    const notesList = await xiaohongshuActions.getNotesList({
      type: 'user_notes',
      limit: 20
    });

    console.log('Notes list:', notesList);

  } finally {
    // 7. æ¸…ç†èµ„æº
    await browserManager.cleanup();
  }
}
```

### 2. **æ™ºèƒ½é¡µé¢åˆ†æ**

```typescript
// æ™ºèƒ½é¡µé¢åˆ†æç¤ºä¾‹
async function intelligentPageAnalysisExample() {
  const browserManager = new CamoufoxManager();
  const pageAnalyzer = new PageAnalyzer(new AIAssistant());
  
  await browserManager.initialize();
  const page = await browserManager.getCurrentPage();
  
  try {
    // å¯¼èˆªåˆ°ç›®æ ‡é¡µé¢
    await page.goto('https://www.xiaohongshu.com/explore');
    
    // 1. åˆ†æé¡µé¢å¸ƒå±€ç±»å‹
    const layoutAnalysis = await pageAnalyzer.analyzeLayoutType(page);
    console.log('Layout analysis:', layoutAnalysis);
    
    // 2. åˆ†æå¸–å­åˆ—è¡¨ç»“æ„
    const postListAnalysis = await pageAnalyzer.analyzePostListStructure(page);
    console.log('Post list analysis:', postListAnalysis);
    
    // 3. åˆ†æå¯è§†å…ƒç´ 
    const visibleAnalysis = await pageAnalyzer.analyzeVisibleElements(page);
    console.log('Visible elements analysis:', visibleAnalysis);
    
    // 4. æ™ºèƒ½æ»šåŠ¨åŠ è½½æ›´å¤šå†…å®¹
    const scrollResult = await pageAnalyzer.smartScrollForContent({
      maxAttempts: 5,
      waitTime: 2000
    });
    console.log('Scroll result:', scrollResult);
    
  } finally {
    await browserManager.cleanup();
  }
}
```

### 3. **é€šç”¨æµè§ˆå™¨è‡ªåŠ¨åŒ–**

```typescript
// é€šç”¨è‡ªåŠ¨åŒ–ç¤ºä¾‹
async function generalAutomationExample() {
  const browserManager = new CamoufoxManager();
  const operationCenter = new PageOperationCenter();
  const elementSelector = new SmartElementSelector(new AIAssistant());
  
  await browserManager.initialize();
  const page = await browserManager.getCurrentPage();
  
  try {
    // 1. å¯¼èˆªåˆ°ç½‘ç«™
    await operationCenter.navigate(page, 'https://example.com');
    
    // 2. æ™ºèƒ½ç‚¹å‡»ç™»å½•æŒ‰é’®
    const loginButton = await elementSelector.selectElement(page, {
      type: 'button',
      text: 'ç™»å½•',
      context: 'login_page'
    });
    await operationCenter.click(page, loginButton.element);
    
    // 3. æ™ºèƒ½å¡«å†™è¡¨å•
    const usernameField = await elementSelector.selectElement(page, {
      type: 'input',
      attributes: { type: 'text', name: 'username' }
    });
    await operationCenter.type(page, usernameField.element, 'testuser');
    
    // 4. æå–é¡µé¢å†…å®¹
    const content = await operationCenter.extractContent(page, {
      includeLinks: true,
      includeImages: true
    });
    console.log('Extracted content:', content);
    
  } finally {
    await browserManager.cleanup();
  }
}
```

## ğŸ”§ é…ç½®å’Œéƒ¨ç½²

### 1. **æ¨¡å—é…ç½®**

```typescript
// config/default.ts
export const defaultConfig = {
  // Camoufoxé…ç½®
  camoufox: {
    headless: process.env.HEADLESS !== 'false',
    launchTimeout: 30000,
    defaultTimeout: 10000,
    viewport: { width: 1920, height: 1080 },
    browserArgs: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage'
    ]
  },
  
  // AIé…ç½®
  ai: {
    enabled: true,
    model: process.env.AI_MODEL || 'gpt-4',
    apiKey: process.env.AI_API_KEY,
    maxTokens: 2000,
    temperature: 0.1
  },
  
  // æ“ä½œé…ç½®
  operations: {
    defaultTimeout: 10000,
    retryCount: 3,
    waitAfterAction: 500,
    scrollDelay: 1000
  },
  
  // Cookieé…ç½®
  cookies: {
    encryptionKey: process.env.COOKIE_ENCRYPTION_KEY,
    storagePath: './cookies/',
    autoSave: true
  }
};
```

### 2. **ç¯å¢ƒå˜é‡**

```bash
# .env
# Camoufoxé…ç½®
HEADLESS=false
CAMOUFOX_TIMEOUT=30000

# AIé…ç½®
AI_MODEL=gpt-4
AI_API_KEY=your_ai_api_key

# å®‰å…¨é…ç½®
COOKIE_ENCRYPTION_KEY=your_encryption_key

# è°ƒè¯•é…ç½®
DEBUG_LEVEL=info
LOG_FILE=./logs/browser-assistant.log
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

### 1. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

```typescript
// src/optimization/PerformanceOptimizer.ts
export class PerformanceOptimizer extends BaseBrowserModule {
  private metrics: PerformanceMetrics[] = [];
  
  async optimizePagePerformance(page: Page): Promise<void> {
    // ç¦ç”¨ä¸å¿…è¦çš„åŠŸèƒ½
    await page.route('**/*.{png,jpg,jpeg,webp}', route => route.abort());
    await page.route('**/*.css', route => route.continue());
    await page.route('**/*.js', route => route.continue());
    
    // å¯ç”¨ç¼“å­˜
    await page.setCacheEnabled(true);
    
    // ä¼˜åŒ–é¡µé¢åŠ è½½
    await page.evaluate(() => {
      // ç¦ç”¨åŠ¨ç”»
      document.body.style.setProperty('transition', 'none', 'important');
      
      // é¢„åŠ è½½å…³é”®èµ„æº
      const links = document.querySelectorAll('link[rel="preload"]');
      links.forEach(link => {
        if (link.getAttribute('as') === 'script') {
          const script = document.createElement('script');
          script.src = link.getAttribute('href');
          document.head.appendChild(script);
        }
      });
    });
  }
  
  async measureOperationPerformance(operation: string, startTime: number): Promise<void> {
    const duration = Date.now() - startTime;
    this.metrics.push({
      operation,
      duration,
      timestamp: new Date()
    });
    
    // è®°å½•æ…¢æ“ä½œ
    if (duration > 5000) {
      this.logger.warn(`Slow operation detected: ${operation} took ${duration}ms`);
    }
  }
}
```

### 2. **ç›‘æ§å’Œæ—¥å¿—**

```typescript
// src/monitoring/MonitoringService.ts
export class MonitoringService extends BaseBrowserModule {
  private operationMetrics: Map<string, OperationMetric> = new Map();
  
  async recordOperation(operation: string, success: boolean, duration: number): Promise<void> {
    const key = `${operation}_${success ? 'success' : 'failure'}`;
    const existing = this.operationMetrics.get(key) || {
      count: 0,
      totalDuration: 0,
      avgDuration: 0
    };
    
    existing.count++;
    existing.totalDuration += duration;
    existing.avgDuration = existing.totalDuration / existing.count;
    
    this.operationMetrics.set(key, existing);
    
    // è®°å½•åˆ°æ—¥å¿—
    this.logger.info(`Operation ${operation} ${success ? 'succeeded' : 'failed'} in ${duration}ms`);
  }
  
  async getPerformanceReport(): Promise<PerformanceReport> {
    const report: PerformanceReport = {
      totalOperations: 0,
      successRate: 0,
      averageDuration: 0,
      topSlowOperations: []
    };
    
    // è®¡ç®—ç»Ÿè®¡æ•°æ®
    let totalOps = 0;
    let successOps = 0;
    let totalDuration = 0;
    
    for (const [key, metric] of this.operationMetrics) {
      totalOps += metric.count;
      totalDuration += metric.totalDuration;
      
      if (key.includes('success')) {
        successOps += metric.count;
      }
    }
    
    report.totalOperations = totalOps;
    report.successRate = totalOps > 0 ? successOps / totalOps : 0;
    report.averageDuration = totalOps > 0 ? totalDuration / totalOps : 0;
    
    // æ‰¾å‡ºæœ€æ…¢çš„æ“ä½œ
    const slowOps = Array.from(this.operationMetrics.entries())
      .sort(([, a], [, b]) => b.avgDuration - a.avgDuration)
      .slice(0, 5);
    
    report.topSlowOperations = slowOps.map(([key, metric]) => ({
      operation: key.replace('_success', '').replace('_failure', ''),
      averageDuration: metric.avgDuration,
      count: metric.count
    }));
    
    return report;
  }
}
```

## ğŸ¯ å®ç°è®¡åˆ’

### Phase 1: æ ¸å¿ƒåŸºç¡€è®¾æ–½ (Week 1-2)
- [x] å®Œæˆæ¶æ„è®¾è®¡å’Œæ–‡æ¡£
- [x] å®ç°åŸºç¡€æ¨¡å—å’Œæ¥å£å®šä¹‰
- [x] å®ŒæˆPageOperationCenter
- [ ] å®ç°CamoufoxManager
- [ ] å®ç°CookieManager
- [ ] å®ç°SmartElementSelector

### Phase 2: æ™ºèƒ½åŠŸèƒ½ (Week 3-4)
- [ ] å®ç°AIAssistant
- [ ] å®ç°PageAnalyzer
- [ ] å®ç°æ™ºèƒ½å†…å®¹æå–
- [ ] å®ç°é¡µé¢ç±»å‹åˆ†æ
- [ ] é›†æˆStagehandçš„observeåŠŸèƒ½

### Phase 3: åº”ç”¨å±‚åŠŸèƒ½ (Week 5-6)
- [ ] å®ç°XiaohongshuActions
- [ ] å®ç°é€šç”¨ç¤¾äº¤åª’ä½“æ“ä½œ
- [ ] å®ç°WebSocketæ§åˆ¶æ¥å£
- [ ] å®Œå–„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

### Phase 4: æµ‹è¯•å’Œä¼˜åŒ– (Week 7-8)
- [ ] ç¼–å†™å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹
- [ ] æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§
- [ ] æ–‡æ¡£å®Œå–„å’Œç¤ºä¾‹
- [ ] å‘å¸ƒå‡†å¤‡å’ŒCI/CD

## ğŸš€ å¿«é€Ÿå¼€å§‹

```typescript
// å¿«é€Ÿå¼€å§‹ç¤ºä¾‹
import { 
  CamoufoxManager, 
  PageOperationCenter, 
  XiaohongshuActions,
  AIAssistant 
} from '@webauto/browser-assistant';

async function quickStart() {
  // åˆå§‹åŒ–ç»„ä»¶
  const browserManager = new CamoufoxManager();
  const operationCenter = new PageOperationCenter();
  const aiAssistant = new AIAssistant();
  const xiaohongshu = new XiaohongshuActions(
    browserManager, 
    operationCenter, 
    aiAssistant
  );

  // å¯åŠ¨æµè§ˆå™¨
  await browserManager.initialize();

  try {
    // æ‰§è¡Œæ“ä½œ
    const status = await xiaohongshu.checkLoginStatus();
    console.log('Login status:', status);
    
  } finally {
    // æ¸…ç†èµ„æº
    await browserManager.cleanup();
  }
}

quickStart();
```

è¿™ä¸ªç»¼åˆè®¾è®¡æ–‡æ¡£ç»“åˆäº†stagehandçš„æ™ºèƒ½è§‚å¯Ÿæ¨¡å¼ã€xiaohongshu-mcpçš„å®ç”¨æ“ä½œæ¨¡å¼å’ŒCamoufoxçš„æŠ€æœ¯ä¼˜åŠ¿ï¼Œæä¾›äº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€æ¶æ„æ¸…æ™°çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–è§£å†³æ–¹æ¡ˆã€‚