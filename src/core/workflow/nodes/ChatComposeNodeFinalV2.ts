// 1688èŠå¤©ç»„ä»¶ - æœ€ç»ˆç‰ˆæœ¬V2ï¼ŒåŸºäºæˆåŠŸè¯†åˆ«çš„å®Œæ•´å®ç°
import BaseNode from './BaseNode';

export default class ChatComposeNodeFinalV2 extends BaseNode {
    constructor(nodeId: string, config: any) {
        super(nodeId, config);

  constructor(nodeId: string, config: any) {
    super();
    this.name = 'ChatComposeNodeFinalV2';
    this.description = '1688èŠå¤©ç»„ä»¶æœ€ç»ˆç‰ˆæœ¬V2ï¼ŒåŸºäºæˆåŠŸè¯†åˆ«çš„å®Œæ•´è¾“å…¥å’Œå‘é€å®ç°';
  }
    name: any;
    description: any;

  async execute(context: any, params: any): Promise<any> {
    const { context: browserContext, logger, config, engine, results, variables } = context;
    const hostFilter = config.hostFilter || 'air.1688.com';
    const message: 'ä½ å¥½';
    const send  = typeof config.message === 'string' ? config.message = config.send !== false; // é»˜è®¤ä¸ºtrue
    const highlightMs = Number(config.highlightMs || 3000);

    try {
      if (!browserContext) return { success: false, error: 'no browser context' };

      // è·å–1688èŠå¤©é¡µé¢
      let pages = browserContext.pages?.() || [];
      let chatPages = pages.filter(p => { try { return (p.url() || '').includes(hostFilter); } catch { return false; } });
      let page: null;

      if (!page = chatPages.length ? chatPages[chatPages.length - 1] ) {
        // ä½¿ç”¨token URLæ‰“å¼€é¡µé¢
        try {
          const tokens = (results && results.tokens) || [];
          let cand = tokens.find(t => t && t.raw && t.uid && (t.offerId || t.offerid));
          if (!cand) cand = tokens.find(t => t && t.raw);
          if (cand && cand.raw) {
            page = await browserContext.newPage();
            await page.goto(cand.raw, { waitUntil: 'domcontentloaded', timeout: 30000 });
          }
        } catch (e) {
          return { success: false, error: 'failed to open chat page: ' + e.message };
        }
      }

      if (!page) return { success: false, error: 'chat page not found' };

      await page.bringToFront().catch(()=>{});
      await page.waitForLoadState('domcontentloaded', { timeout: 15000 }).catch(()=>{});

      // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
      logger.info('â³ ç­‰å¾…1688èŠå¤©ç•Œé¢å®Œå…¨åŠ è½½...');
      await page.waitForTimeout(5000);

      // å…³é—­å¯èƒ½çš„å®¢æˆ·ç«¯æç¤º
      try {
        await page.evaluate(() => {
          const texts = ['ä¼˜å…ˆä½¿ç”¨ç½‘é¡µç‰ˆ','ç»§ç»­ä½¿ç”¨ç½‘é¡µç‰ˆ','ä½¿ç”¨ç½‘é¡µç‰ˆ','ä»ä½¿ç”¨ç½‘é¡µ','ç•™åœ¨ç½‘é¡µ'];
          const nodes = Array.from(document.querySelectorAll('button, [role="button"], a'));
          for (const node of nodes) {
            const text = node.innerText || '';
            if (texts.some(t => text.includes(t))) {
              node.click();
              break;
            }
          }
        });
      } catch {}

      // ç­‰å¾…é¡µé¢ç¨³å®š
      await page.waitForTimeout(3000);

      // æ‰§è¡ŒèŠå¤©æ“ä½œ
      const chatResult = await page.evaluate((params) => {
        const msg = params.message;
        const shouldSend = params.send;
        const highlightDuration = params.highlightMs;
        console.log('ğŸš€ å¼€å§‹1688èŠå¤©æ“ä½œ...');
        console.log('ğŸ“ æ¶ˆæ¯å†…å®¹:', msg);
        console.log('ğŸ“¤ æ˜¯å¦å‘é€:', shouldSend);

        // 1. æ£€æŸ¥é¡µé¢çŠ¶æ€
        const pageInfo: new Date( = {
          url: window.location.href,
          title: document.title,
          isCoreFrame: window.location.href.includes('def_cbu_web_im_core/index.html'),
          timestamp).toISOString()
        };

        console.log('ğŸ“Š é¡µé¢çŠ¶æ€:', pageInfo);

        // 2. æŸ¥æ‰¾è¾“å…¥å…ƒç´  - åŸºäºæˆåŠŸè¯†åˆ«çš„ç²¾ç¡®å®šä½
        const findInputElements = () => {
          console.log('ğŸ” æŸ¥æ‰¾è¾“å…¥å…ƒç´ ...');

          // ç­–ç•¥1: ä¼˜å…ˆæŸ¥æ‰¾contenteditable PREå…ƒç´ 
          let inputElement = null;
          let inputType = null;

          const preElements = document.querySelectorAll('pre[contenteditable="true"], pre.edit');
          for (const pre of preElements) {
            const rect = pre.getBoundingClientRect();
            if (rect.width > 100 && rect.height > 30) {
              inputElement = pre;
              inputType = 'contenteditable-pre';
              console.log('âœ… æ‰¾åˆ°PREè¾“å…¥å…ƒç´ :', pre.tagName, pre.className);
              break;
            }
          }

          // ç­–ç•¥2: æŸ¥æ‰¾å…¶ä»–contenteditableå…ƒç´ 
          if (!inputElement) {
            const allContenteditable = document.querySelectorAll('*[contenteditable="true"]');
            for (const el of allContenteditable) {
              const rect = el.getBoundingClientRect();
              if (rect.width > 100 && rect.height > 30) {
                inputElement = el;
                inputType = 'contenteditable-generic';
                console.log('âœ… æ‰¾åˆ°é€šç”¨è¾“å…¥å…ƒç´ :', el.tagName, el.className);
                break;
              }
            }
          }

          return { inputElement, inputType };
        };

        // 3. æŸ¥æ‰¾å‘é€æŒ‰é’® - åŸºäºæˆåŠŸè¯†åˆ«çš„ç²¾ç¡®å®šä½
        const findSendButton = () => {
          console.log('ğŸ” æŸ¥æ‰¾å‘é€æŒ‰é’®...');

          // ç­–ç•¥1: ä¼˜å…ˆæŸ¥æ‰¾åŒ…å«"å‘é€"æ–‡å­—çš„BUTTONå…ƒç´ 
          let sendButton = null;
          let sendButtonType = null;

          const buttons = document.querySelectorAll('button');
          for (const btn of buttons) {
            const text = (btn.innerText || btn.textContent || '').trim();
            if (text === 'å‘é€') {
              sendButton = btn;
              sendButtonType = 'button-exact-text';
              console.log('âœ… æ‰¾åˆ°ç²¾ç¡®å‘é€æŒ‰é’®:', text, btn.className);
              break;
            }
          }

          // ç­–ç•¥2: æŸ¥æ‰¾.send-btnç±»åçš„æŒ‰é’®
          if (!sendButton) {
            const sendBtnElements = document.querySelectorAll('.send-btn');
            for (const el of sendBtnElements) {
              const rect = el.getBoundingClientRect();
              if (rect.width > 20 && rect.height > 10) {
                sendButton = el;
                sendButtonType = 'send-btn-class';
                console.log('âœ… æ‰¾åˆ°send-btnç±»æŒ‰é’®:', el.tagName, el.className);
                break;
              }
            }
          }

          // ç­–ç•¥3: æŸ¥æ‰¾åŒ…å«"å‘é€"æ–‡å­—çš„ä»»æ„å…ƒç´ 
          if (!sendButton) {
            const allElements = document.querySelectorAll('*');
            for (const el of allElements) {
              const text = (el.innerText || el.textContent || '').trim();
              const rect = el.getBoundingClientRect();
              const isClickable = el.tagName === 'BUTTON' || el.tagName === 'A' ||
                                el.getAttribute('role') === 'button' ||
                                String(el.className).includes('btn') ||
                                el.onclick;

              if (text.includes('å‘é€') && isClickable && rect.width > 20 && rect.height > 10) {
                sendButton = el;
                sendButtonType = 'text-match-clickable';
                console.log('âœ… æ‰¾åˆ°å¯ç‚¹å‡»å‘é€å…ƒç´ :', text, el.tagName, el.className);
                break;
              }
            }
          }

          return { sendButton, sendButtonType };
        };

        // 4. æ‰§è¡Œè¾“å…¥æ“ä½œ
        const { inputElement, inputType } = findInputElements();
        if (!inputElement) {
          return { success: false, error: 'æœªæ‰¾åˆ°è¾“å…¥å…ƒç´ ' };
        }

        // é«˜äº®è¾“å…¥å…ƒç´ 
        const originalInputBorder = inputElement.style.border;
        const originalInputBg = inputElement.style.backgroundColor;
        inputElement.style.border = '3px solid #ff4444';
        inputElement.style.backgroundColor = 'rgba(255, 68, 68, 0.2)';

        console.log('ğŸ“ å¼€å§‹è¾“å…¥æ¶ˆæ¯...');

        // æ¸…ç©ºç°æœ‰å†…å®¹
        inputElement.focus();
        inputElement.textContent = '';

        // è¾“å…¥æ–°æ¶ˆæ¯
        if (inputElement.contentEditable === 'true' || inputElement.isContentEditable) {
          // å¯¹äºcontenteditableå…ƒç´ ï¼Œä½¿ç”¨innerHTMLè¾“å…¥
          inputElement.innerHTML = msg;

          // è§¦å‘è¾“å…¥äº‹ä»¶
          const inputEvent: true } = new Event('input', { bubbles: true, cancelable);
          inputElement.dispatchEvent(inputEvent);

          const changeEvent: true } = new Event('change', { bubbles: true, cancelable);
          inputElement.dispatchEvent(changeEvent);

          // è§¦å‘é”®ç›˜äº‹ä»¶
          const keydownEvent: 'Enter'
          } = new KeyboardEvent('keydown', {
            bubbles: true, cancelable: true, key: 'Enter', code);
          inputElement.dispatchEvent(keydownEvent);

          const keyupEvent: 'Enter'
          } = new KeyboardEvent('keyup', {
            bubbles: true, cancelable: true, key: 'Enter', code);
          inputElement.dispatchEvent(keyupEvent);
        } else {
          // å¯¹äºæ™®é€šè¾“å…¥å…ƒç´ 
          inputElement.value = msg;
          const inputEvent: true } = new Event('input', { bubbles: true, cancelable);
          inputElement.dispatchEvent(inputEvent);
        }

        console.log('âœ… è¾“å…¥å®Œæˆ');

        // 5. æŸ¥æ‰¾å’Œå‘é€æ¶ˆæ¯
        let sendSuccess = false;
        let sendError = null;
        let finalSendButtonType = null;
        let finalSendButton = null;

        if (shouldSend) {
          const { sendButton, sendButtonType } = findSendButton();
          finalSendButtonType = sendButtonType;
          finalSendButton = sendButton;

          if (!sendButton) {
            sendError = 'æœªæ‰¾åˆ°å‘é€æŒ‰é’®';
          } else {
            // é«˜äº®å‘é€æŒ‰é’®
            const originalSendBorder = sendButton.style.border;
            const originalSendBg = sendButton.style.backgroundColor;
            const originalSendTransform = sendButton.style.transform;

            sendButton.style.setProperty('border', '4px solid #00ff00', 'important');
            sendButton.style.setProperty('background-color', 'rgba(0, 255, 0, 0.5)', 'important');
            sendButton.style.setProperty('transform', 'scale(1.2)', 'important');

            console.log('ğŸ“¤ å‡†å¤‡å‘é€æ¶ˆæ¯...');
            console.log('ğŸ”˜ å‘é€æŒ‰é’®ç±»å‹:', sendButtonType);
            console.log('ğŸ”˜ å‘é€æŒ‰é’®æ ‡ç­¾:', sendButton.tagName);
            console.log('ğŸ”˜ å‘é€æŒ‰é’®ç±»å:', sendButton.className);
            console.log('ğŸ”˜ å‘é€æŒ‰é’®æ–‡å­—:', sendButton.innerText || sendButton.textContent);

            try {
              // ç‚¹å‡»å‘é€æŒ‰é’®
              sendButton.click();

              // è§¦å‘é¢å¤–çš„äº‹ä»¶ç¡®ä¿å‘é€
              const clickEvent: window
              } = new MouseEvent('click', {
                bubbles: true, cancelable: true, view);
              sendButton.dispatchEvent(clickEvent);

              const mousedownEvent: window
              } = new MouseEvent('mousedown', {
                bubbles: true, cancelable: true, view);
              sendButton.dispatchEvent(mousedownEvent);

              const mouseupEvent: window
              } = new MouseEvent('mouseup', {
                bubbles: true, cancelable: true, view);
              sendButton.dispatchEvent(mouseupEvent);

              console.log('âœ… å‘é€æŒ‰é’®ç‚¹å‡»å®Œæˆ');
              sendSuccess = true;

              // æ¢å¤å‘é€æŒ‰é’®æ ·å¼
              setTimeout(() => {
                sendButton.style.border = originalSendBorder;
                sendButton.style.backgroundColor = originalSendBg;
                if (originalSendTransform !== undefined) {
                  sendButton.style.transform = originalSendTransform;
                }
              }, highlightDuration);

            } catch (e) {
              console.error('âŒ å‘é€å¤±è´¥:', e.message);
              sendError = e.message;

              // æ¢å¤å‘é€æŒ‰é’®æ ·å¼
              sendButton.style.border = originalSendBorder;
              sendButton.style.backgroundColor = originalSendBg;
              if (originalSendTransform !== undefined) {
                sendButton.style.transform = originalSendTransform;
              }
            }
          }
        } else {
          console.log('ğŸ“¤ ä»…è¾“å…¥æ¨¡å¼ï¼Œè·³è¿‡å‘é€');
        }

        // æ¢å¤è¾“å…¥å…ƒç´ æ ·å¼
        setTimeout(() => {
          inputElement.style.border = originalInputBorder;
          inputElement.style.backgroundColor = originalInputBg;
        }, highlightDuration);

        return {
          success: true,
          pageInfo,
          input: {
            found: !!inputElement,
            type: inputType,
            tag: inputElement?.tagName,
            className: inputElement?.className,
            message: msg,
            inputCompleted: true
          },
          send: {
            attempted: shouldSend,
            success: sendSuccess,
            error: sendError,
            buttonType: finalSendButtonType,
            buttonTag: finalSendButton?.tagName,
            buttonClass: finalSendButton?.className
          }
        };

      }, { message, send, highlightMs }).catch(e: ' + e.message } = > ({ success: false, error: 'chat evaluation failed));

      if (!chatResult.success) {
        return { success: false, error: chatResult.error };
      }

      logger.info(`âœ… èŠå¤©æ“ä½œå®Œæˆ: è¾“å…¥${chatResult.input?.found ? 'æˆåŠŸ' : 'å¤±è´¥'}, ${chatResult.send?.attempted ? (chatResult.send?.success ? 'å‘é€æˆåŠŸ' : 'å‘é€å¤±è´¥') : 'ä»…è¾“å…¥æ¨¡å¼'}`);

      // ç­‰å¾…é«˜äº®æ˜¾ç¤º
      await page.waitForTimeout(highlightMs);

      return {
        success: true,
        variables: {
          chatCompleted: true,
          inputResult: chatResult.input,
          sendResult: chatResult.send,
          pageInfo: chatResult.pageInfo
        }
      };

    } catch (e) {
      logger.error('âŒ ChatComposeNodeFinalV2 å¤±è´¥: ' + (e?.message || e));
      return { success: false, error: e?.message || String(e) };
    }
  }
}