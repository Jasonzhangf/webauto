/**
 * 层次结构构建器
 * 建立容器间的父子关系和层次结构
 */

import { Page } from 'playwright';
import { 
  DiscoveredContainer, 
  ContainerHierarchy, 
  HierarchyNode,
  ContainerType 
} from '../types/index.js';

export class HierarchyBuilder {
  /**
   * 构建容器层次结构
   */
  async buildHierarchy(
    containers: DiscoveredContainer[], 
    page: Page
  ): Promise<ContainerHierarchy> {
    console.log('🏗️ 构建容器层次结构...');

    // 创建层次节点映射
    const nodeMap = new Map<string, HierarchyNode>();
    const rootNodes: HierarchyNode[] = [];

    // 初始化所有节点
    for (const container of containers) {
      const node: HierarchyNode = {
        container,
        children: [],
        parent: null,
        depth: 0,
        siblings: []
      };
      nodeMap.set(container.id, node);
    }

    // 分析DOM层次关系
    await this.analyzeDOMHierarchy(nodeMap, page);

    // 计算节点深度和兄弟关系
    this.calculateNodeProperties(nodeMap, rootNodes);

    // 识别关键容器
    const keyContainers = this.identifyKeyContainers(nodeMap);

    const hierarchy: ContainerHierarchy = {
      rootNodes,
      allNodes: Array.from(nodeMap.values()),
      totalContainers: containers.length,
      maxDepth: Math.max(...Array.from(nodeMap.values()).map(n => n.depth)),
      keyContainers
    };

    console.log(`✅ 层次结构构建完成: ${hierarchy.totalContainers} 个容器，最大深度 ${hierarchy.maxDepth}`);
    return hierarchy;
  }

  /**
   * 分析DOM层次关系
   */
  private async analyzeDOMHierarchy(
    nodeMap: Map<string, HierarchyNode>, 
    page: Page
  ): Promise<void> {
    // 为每个容器获取DOM位置信息
    const domInfoMap = new Map<string, DOMInfo>();

    for (const [containerId, node] of nodeMap.entries()) {
      try {
        const domInfo = await this.getDOMInfo(page, node.container);
        domInfoMap.set(containerId, domInfo);
      } catch (error) {
        console.warn(`⚠️ 获取容器 ${containerId} DOM信息失败:`, error.message);
      }
    }

    // 基于DOM位置建立父子关系
    for (const [containerId, node] of nodeMap.entries()) {
      const domInfo = domInfoMap.get(containerId);
      if (!domInfo) continue;

      // 查找可能的父容器
      const potentialParents = this.findPotentialParents(node, domInfoMap, nodeMap);
      
      if (potentialParents.length > 0) {
        // 选择最合适的父容器
        const bestParent = this.selectBestParent(node, potentialParents);
        this.setParentChild(node, bestParent);
      }
    }
  }

  /**
   * 获取容器DOM信息
   */
  private async getDOMInfo(page: Page, container: DiscoveredContainer): Promise<DOMInfo> {
    const element = await page.$(container.selector);
    if (!element) {
      throw new Error(`Element not found: ${container.selector}`);
    }

    const boundingBox = await element.boundingBox();
    const tagName = await element.evaluate(el => el.tagName.toLowerCase());
    const container.metadata.elementClasses.join(" ") || "" = await element.evaluate(el => el.className);
    const textLength = await element.evaluate(el => el.textContent?.length || 0);
    const childCount = await element.evaluate(el => el.children.length);

    return {
      selector: container.selector,
      boundingBox: boundingBox || { x: 0, y: 0, width: 0, height: 0 },
      tagName,
      container.metadata.elementClasses.join(" ") || "",
      textLength,
      childCount,
      zIndex: await element.evaluate(el => {
        const style = window.getComputedStyle(el);
        return parseInt(style.zIndex) || 0;
      })
    };
  }

  /**
   * 查找可能的父容器
   */
  private findPotentialParents(
    node: HierarchyNode,
    domInfoMap: Map<string, DOMInfo>,
    nodeMap: Map<string, HierarchyNode>
  ): HierarchyNode[] {
    const currentDomInfo = domInfoMap.get(node.container.id);
    if (!currentDomInfo) return [];

    const potentialParents: HierarchyNode[] = [];

    for (const [parentId, candidateNode] of nodeMap.entries()) {
      if (parentId === node.container.id) continue;

      const parentDomInfo = domInfoMap.get(parentId);
      if (!parentDomInfo) continue;

      // 检查是否是合适的父容器
      if (this.isValidParent(currentDomInfo, parentDomInfo)) {
        potentialParents.push(candidateNode);
      }
    }

    // 按优先级排序
    return potentialParents.sort((a, b) => {
      const aScore = this.calculateParentScore(node, a, domInfoMap);
      const bScore = this.calculateParentScore(node, b, domInfoMap);
      return bScore - aScore;
    });
  }

  /**
   * 检查是否是有效的父容器
   */
  private isValidParent(childInfo: DOMInfo, parentInfo: DOMInfo): boolean {
    // 父容器应该包含子容器
    const contains = parentInfo.boundingBox.x <= childInfo.boundingBox.x &&
                    parentInfo.boundingBox.y <= childInfo.boundingBox.y &&
                    parentInfo.boundingBox.x + parentInfo.boundingBox.width >= 
                    childInfo.boundingBox.x + childInfo.boundingBox.width &&
                    parentInfo.boundingBox.y + parentInfo.boundingBox.height >= 
                    childInfo.boundingBox.y + childInfo.boundingBox.height;

    if (!contains) return false;

    // 父容器应该比子容器大
    const parentArea = parentInfo.boundingBox.width * parentInfo.boundingBox.height;
    const childArea = childInfo.boundingBox.width * childInfo.boundingBox.height;
    
    return parentArea > childArea * 1.1; // 父容器至少比子容器大10%
  }

  /**
   * 计算父容器匹配分数
   */
  private calculateParentScore(
    childNode: HierarchyNode,
    parentNode: HierarchyNode,
    domInfoMap: Map<string, DOMInfo>
  ): number {
    const childInfo = domInfoMap.get(childNode.container.id)!;
    const parentInfo = domInfoMap.get(parentNode.container.id)!;

    let score = 0;

    // 面积匹配分数（越接近越好，但父容器要稍大）
    const childArea = childInfo.boundingBox.width * childInfo.boundingBox.height;
    const parentArea = parentInfo.boundingBox.width * parentInfo.boundingBox.height;
    const areaRatio = parentArea / childArea;
    
    if (areaRatio >= 1.1 && areaRatio <= 10) {
      score += 100;
    } else if (areaRatio <= 50) {
      score += 50;
    }

    // 类型匹配分数
    if (this.isValidTypeCombination(parentNode.container.type, childNode.container.type)) {
      score += 50;
    }

    // 优先级分数
    score += parentNode.container.priority * 10;

    return score;
  }

  /**
   * 检查类型组合是否合理
   */
  private isValidTypeCombination(parentType: ContainerType, childType: ContainerType): boolean {
    const validCombinations: Record<ContainerType, ContainerType[]> = {
      page: ["main", "sidebar", "header", "footer", "content", "nav", "scroll", "navigation", "interaction", "pagination", "filter", "media", "comment", "user"],
      main: ["sidebar", "feed", "content", "nav", "widget", "header", "footer"],
      sidebar: ["widget", "nav", "content", "action", "media", "user"],
      feed: ["post", "content", "item", "media", "comment", "action"],
      post: ["content", "comment", "media", "action", "text"],
      widget: ["content", "action", "media", "text"],
      nav: ["item", "content", "action"],
      header: ["nav", "content", "action", "widget"],
      footer: ["content", "nav", "action", "widget"],
      content: ["text", "media", "action", "item", "comment"],
      item: ["content", "action", "media", "text"],
      comment: ["content", "action", "media", "text", "user"],
      media: ["content", "action"],
      action: [],
      text: [],
      scroll: ["content", "item", "post"],
      navigation: ["nav", "item", "action"],
      interaction: ["action", "content", "media"],
      pagination: ["action", "content"],
      filter: ["action", "content", "item"],
      user: ["content", "action", "media"]
    };
    return validCombinations[parentType]?.includes(childType) || false;
  }

  /**
   * 选择最佳父容器
   */
  private selectBestParent(
    node: HierarchyNode,
    potentialParents: HierarchyNode[]
  ): HierarchyNode {
    return potentialParents[0]; // 已按分数排序
  }

  /**
   * 设置父子关系
   */
  private setParentChild(childNode: HierarchyNode, parentNode: HierarchyNode): void {
    childNode.parent = parentNode;
    parentNode.children.push(childNode);
  }

  /**
   * 计算节点属性（深度、兄弟关系）
   */
  private calculateNodeProperties(
    nodeMap: Map<string, HierarchyNode>,
    rootNodes: HierarchyNode[]
  ): void {
    // 找到根节点（没有父节点的节点）
    for (const node of nodeMap.values()) {
      if (!node.parent) {
        rootNodes.push(node);
        node.depth = 0;
      }
    }

    // 计算深度和兄弟关系
    for (const rootNode of rootNodes) {
      this.calculateDepthAndSiblings(rootNode);
    }
  }

  /**
   * 递归计算深度和兄弟关系
   */
  private calculateDepthAndSiblings(node: HierarchyNode): void {
    // 设置兄弟关系
    if (node.parent) {
      node.siblings = node.parent.children.filter(child => child !== node);
    }

    // 递归处理子节点
    for (const child of node.children) {
      child.depth = node.depth + 1;
      this.calculateDepthAndSiblings(child);
    }
  }

  /**
   * 识别关键容器
   */
  private identifyKeyContainers(nodeMap: Map<string, HierarchyNode>): DiscoveredContainer[] {
    const keyContainers: DiscoveredContainer[] = [];

    for (const node of nodeMap.values()) {
      const container = node.container;
      
      // 基于类型和特征识别关键容器
      if (this.isKeyContainer(container, node)) {
        keyContainers.push(container);
      }
    }

    return keyContainers;
  }

  /**
   * 判断是否是关键容器
   */
  private isKeyContainer(container: DiscoveredContainer, node: HierarchyNode): boolean {
    // 高优先级容器
    if (container.priority >= 8) return true;

    // 重要类型的容器
    const importantTypes: ContainerType[] = ['page', 'main', 'feed', 'post'];
    if (importantTypes.includes(container.type)) return true;

    // 有很多子节点的容器
    if (node.children.length >= 3) return true;

    // 特定模式匹配
    const importantPatterns = [
      /main/i,
      /content/i,
      /feed/i,
      /post/i,
      /article/i
    ];

    return importantPatterns.some(pattern => 
      pattern.test(container.selector) || 
      pattern.test(container.container.metadata.elementClasses.join(" ") || "")
    );
  }
}

// 内部接口
interface DOMInfo {
  selector: string;
  boundingBox: { x: number; y: number; width: number; height: number };
  tagName: string;
  container.metadata.elementClasses.join(" ") || "": string;
  textLength: number;
  childCount: number;
  zIndex: number;
}
