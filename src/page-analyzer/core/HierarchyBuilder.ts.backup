/**
 * å±‚æ¬¡ç»“æ„æ„å»ºå™¨
 * å»ºç«‹å®¹å™¨é—´çš„çˆ¶å­å…³ç³»å’Œå±‚æ¬¡ç»“æ„
 */

import { Page } from 'playwright';
import { 
  DiscoveredContainer, 
  ContainerHierarchy, 
  HierarchyNode,
  ContainerType 
} from '../types/index.js';

export class HierarchyBuilder {
  /**
   * æ„å»ºå®¹å™¨å±‚æ¬¡ç»“æ„
   */
  async buildHierarchy(
    containers: DiscoveredContainer[], 
    page: Page
  ): Promise<ContainerHierarchy> {
    console.log('ğŸ—ï¸ æ„å»ºå®¹å™¨å±‚æ¬¡ç»“æ„...');

    // åˆ›å»ºå±‚æ¬¡èŠ‚ç‚¹æ˜ å°„
    const nodeMap = new Map<string, HierarchyNode>();
    const rootNodes: HierarchyNode[] = [];

    // åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹
    for (const container of containers) {
      const node: HierarchyNode = {
        container,
        children: [],
        parent: null,
        depth: 0,
        siblings: []
      };
      nodeMap.set(container.id, node);
    }

    // åˆ†æDOMå±‚æ¬¡å…³ç³»
    await this.analyzeDOMHierarchy(nodeMap, page);

    // è®¡ç®—èŠ‚ç‚¹æ·±åº¦å’Œå…„å¼Ÿå…³ç³»
    this.calculateNodeProperties(nodeMap, rootNodes);

    // è¯†åˆ«å…³é”®å®¹å™¨
    const keyContainers = this.identifyKeyContainers(nodeMap);

    const hierarchy: ContainerHierarchy = {
      rootNodes,
      allNodes: Array.from(nodeMap.values()),
      totalContainers: containers.length,
      maxDepth: Math.max(...Array.from(nodeMap.values()).map(n => n.depth)),
      keyContainers
    };

    console.log(`âœ… å±‚æ¬¡ç»“æ„æ„å»ºå®Œæˆ: ${hierarchy.totalContainers} ä¸ªå®¹å™¨ï¼Œæœ€å¤§æ·±åº¦ ${hierarchy.maxDepth}`);
    return hierarchy;
  }

  /**
   * åˆ†æDOMå±‚æ¬¡å…³ç³»
   */
  private async analyzeDOMHierarchy(
    nodeMap: Map<string, HierarchyNode>, 
    page: Page
  ): Promise<void> {
    // ä¸ºæ¯ä¸ªå®¹å™¨è·å–DOMä½ç½®ä¿¡æ¯
    const domInfoMap = new Map<string, DOMInfo>();

    for (const [containerId, node] of nodeMap.entries()) {
      try {
        const domInfo = await this.getDOMInfo(page, node.container);
        domInfoMap.set(containerId, domInfo);
      } catch (error) {
        console.warn(`âš ï¸ è·å–å®¹å™¨ ${containerId} DOMä¿¡æ¯å¤±è´¥:`, error.message);
      }
    }

    // åŸºäºDOMä½ç½®å»ºç«‹çˆ¶å­å…³ç³»
    for (const [containerId, node] of nodeMap.entries()) {
      const domInfo = domInfoMap.get(containerId);
      if (!domInfo) continue;

      // æŸ¥æ‰¾å¯èƒ½çš„çˆ¶å®¹å™¨
      const potentialParents = this.findPotentialParents(node, domInfoMap, nodeMap);
      
      if (potentialParents.length > 0) {
        // é€‰æ‹©æœ€åˆé€‚çš„çˆ¶å®¹å™¨
        const bestParent = this.selectBestParent(node, potentialParents);
        this.setParentChild(node, bestParent);
      }
    }
  }

  /**
   * è·å–å®¹å™¨DOMä¿¡æ¯
   */
  private async getDOMInfo(page: Page, container: DiscoveredContainer): Promise<DOMInfo> {
    const element = await page.$(container.selector);
    if (!element) {
      throw new Error(`Element not found: ${container.selector}`);
    }

    const boundingBox = await element.boundingBox();
    const tagName = await element.evaluate(el => el.tagName.toLowerCase());
    const container.metadata.elementClasses.join(" ") || "" = await element.evaluate(el => el.className);
    const textLength = await element.evaluate(el => el.textContent?.length || 0);
    const childCount = await element.evaluate(el => el.children.length);

    return {
      selector: container.selector,
      boundingBox: boundingBox || { x: 0, y: 0, width: 0, height: 0 },
      tagName,
      container.metadata.elementClasses.join(" ") || "",
      textLength,
      childCount,
      zIndex: await element.evaluate(el => {
        const style = window.getComputedStyle(el);
        return parseInt(style.zIndex) || 0;
      })
    };
  }

  /**
   * æŸ¥æ‰¾å¯èƒ½çš„çˆ¶å®¹å™¨
   */
  private findPotentialParents(
    node: HierarchyNode,
    domInfoMap: Map<string, DOMInfo>,
    nodeMap: Map<string, HierarchyNode>
  ): HierarchyNode[] {
    const currentDomInfo = domInfoMap.get(node.container.id);
    if (!currentDomInfo) return [];

    const potentialParents: HierarchyNode[] = [];

    for (const [parentId, candidateNode] of nodeMap.entries()) {
      if (parentId === node.container.id) continue;

      const parentDomInfo = domInfoMap.get(parentId);
      if (!parentDomInfo) continue;

      // æ£€æŸ¥æ˜¯å¦æ˜¯åˆé€‚çš„çˆ¶å®¹å™¨
      if (this.isValidParent(currentDomInfo, parentDomInfo)) {
        potentialParents.push(candidateNode);
      }
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    return potentialParents.sort((a, b) => {
      const aScore = this.calculateParentScore(node, a, domInfoMap);
      const bScore = this.calculateParentScore(node, b, domInfoMap);
      return bScore - aScore;
    });
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„çˆ¶å®¹å™¨
   */
  private isValidParent(childInfo: DOMInfo, parentInfo: DOMInfo): boolean {
    // çˆ¶å®¹å™¨åº”è¯¥åŒ…å«å­å®¹å™¨
    const contains = parentInfo.boundingBox.x <= childInfo.boundingBox.x &&
                    parentInfo.boundingBox.y <= childInfo.boundingBox.y &&
                    parentInfo.boundingBox.x + parentInfo.boundingBox.width >= 
                    childInfo.boundingBox.x + childInfo.boundingBox.width &&
                    parentInfo.boundingBox.y + parentInfo.boundingBox.height >= 
                    childInfo.boundingBox.y + childInfo.boundingBox.height;

    if (!contains) return false;

    // çˆ¶å®¹å™¨åº”è¯¥æ¯”å­å®¹å™¨å¤§
    const parentArea = parentInfo.boundingBox.width * parentInfo.boundingBox.height;
    const childArea = childInfo.boundingBox.width * childInfo.boundingBox.height;
    
    return parentArea > childArea * 1.1; // çˆ¶å®¹å™¨è‡³å°‘æ¯”å­å®¹å™¨å¤§10%
  }

  /**
   * è®¡ç®—çˆ¶å®¹å™¨åŒ¹é…åˆ†æ•°
   */
  private calculateParentScore(
    childNode: HierarchyNode,
    parentNode: HierarchyNode,
    domInfoMap: Map<string, DOMInfo>
  ): number {
    const childInfo = domInfoMap.get(childNode.container.id)!;
    const parentInfo = domInfoMap.get(parentNode.container.id)!;

    let score = 0;

    // é¢ç§¯åŒ¹é…åˆ†æ•°ï¼ˆè¶Šæ¥è¿‘è¶Šå¥½ï¼Œä½†çˆ¶å®¹å™¨è¦ç¨å¤§ï¼‰
    const childArea = childInfo.boundingBox.width * childInfo.boundingBox.height;
    const parentArea = parentInfo.boundingBox.width * parentInfo.boundingBox.height;
    const areaRatio = parentArea / childArea;
    
    if (areaRatio >= 1.1 && areaRatio <= 10) {
      score += 100;
    } else if (areaRatio <= 50) {
      score += 50;
    }

    // ç±»å‹åŒ¹é…åˆ†æ•°
    if (this.isValidTypeCombination(parentNode.container.type, childNode.container.type)) {
      score += 50;
    }

    // ä¼˜å…ˆçº§åˆ†æ•°
    score += parentNode.container.priority * 10;

    return score;
  }

  /**
   * æ£€æŸ¥ç±»å‹ç»„åˆæ˜¯å¦åˆç†
   */
  private isValidTypeCombination(parentType: ContainerType, childType: ContainerType): boolean {
    const validCombinations: Record<ContainerType, ContainerType[]> = {
      page: ["main", "sidebar", "header", "footer", "content", "nav", "scroll", "navigation", "interaction", "pagination", "filter", "media", "comment", "user"],
      main: ["sidebar", "feed", "content", "nav", "widget", "header", "footer"],
      sidebar: ["widget", "nav", "content", "action", "media", "user"],
      feed: ["post", "content", "item", "media", "comment", "action"],
      post: ["content", "comment", "media", "action", "text"],
      widget: ["content", "action", "media", "text"],
      nav: ["item", "content", "action"],
      header: ["nav", "content", "action", "widget"],
      footer: ["content", "nav", "action", "widget"],
      content: ["text", "media", "action", "item", "comment"],
      item: ["content", "action", "media", "text"],
      comment: ["content", "action", "media", "text", "user"],
      media: ["content", "action"],
      action: [],
      text: [],
      scroll: ["content", "item", "post"],
      navigation: ["nav", "item", "action"],
      interaction: ["action", "content", "media"],
      pagination: ["action", "content"],
      filter: ["action", "content", "item"],
      user: ["content", "action", "media"]
    };
    return validCombinations[parentType]?.includes(childType) || false;
  }

  /**
   * é€‰æ‹©æœ€ä½³çˆ¶å®¹å™¨
   */
  private selectBestParent(
    node: HierarchyNode,
    potentialParents: HierarchyNode[]
  ): HierarchyNode {
    return potentialParents[0]; // å·²æŒ‰åˆ†æ•°æ’åº
  }

  /**
   * è®¾ç½®çˆ¶å­å…³ç³»
   */
  private setParentChild(childNode: HierarchyNode, parentNode: HierarchyNode): void {
    childNode.parent = parentNode;
    parentNode.children.push(childNode);
  }

  /**
   * è®¡ç®—èŠ‚ç‚¹å±æ€§ï¼ˆæ·±åº¦ã€å…„å¼Ÿå…³ç³»ï¼‰
   */
  private calculateNodeProperties(
    nodeMap: Map<string, HierarchyNode>,
    rootNodes: HierarchyNode[]
  ): void {
    // æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼ˆæ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼‰
    for (const node of nodeMap.values()) {
      if (!node.parent) {
        rootNodes.push(node);
        node.depth = 0;
      }
    }

    // è®¡ç®—æ·±åº¦å’Œå…„å¼Ÿå…³ç³»
    for (const rootNode of rootNodes) {
      this.calculateDepthAndSiblings(rootNode);
    }
  }

  /**
   * é€’å½’è®¡ç®—æ·±åº¦å’Œå…„å¼Ÿå…³ç³»
   */
  private calculateDepthAndSiblings(node: HierarchyNode): void {
    // è®¾ç½®å…„å¼Ÿå…³ç³»
    if (node.parent) {
      node.siblings = node.parent.children.filter(child => child !== node);
    }

    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    for (const child of node.children) {
      child.depth = node.depth + 1;
      this.calculateDepthAndSiblings(child);
    }
  }

  /**
   * è¯†åˆ«å…³é”®å®¹å™¨
   */
  private identifyKeyContainers(nodeMap: Map<string, HierarchyNode>): DiscoveredContainer[] {
    const keyContainers: DiscoveredContainer[] = [];

    for (const node of nodeMap.values()) {
      const container = node.container;
      
      // åŸºäºç±»å‹å’Œç‰¹å¾è¯†åˆ«å…³é”®å®¹å™¨
      if (this.isKeyContainer(container, node)) {
        keyContainers.push(container);
      }
    }

    return keyContainers;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦æ˜¯å…³é”®å®¹å™¨
   */
  private isKeyContainer(container: DiscoveredContainer, node: HierarchyNode): boolean {
    // é«˜ä¼˜å…ˆçº§å®¹å™¨
    if (container.priority >= 8) return true;

    // é‡è¦ç±»å‹çš„å®¹å™¨
    const importantTypes: ContainerType[] = ['page', 'main', 'feed', 'post'];
    if (importantTypes.includes(container.type)) return true;

    // æœ‰å¾ˆå¤šå­èŠ‚ç‚¹çš„å®¹å™¨
    if (node.children.length >= 3) return true;

    // ç‰¹å®šæ¨¡å¼åŒ¹é…
    const importantPatterns = [
      /main/i,
      /content/i,
      /feed/i,
      /post/i,
      /article/i
    ];

    return importantPatterns.some(pattern => 
      pattern.test(container.selector) || 
      pattern.test(container.container.metadata.elementClasses.join(" ") || "")
    );
  }
}

// å†…éƒ¨æ¥å£
interface DOMInfo {
  selector: string;
  boundingBox: { x: number; y: number; width: number; height: number };
  tagName: string;
  container.metadata.elementClasses.join(" ") || "": string;
  textLength: number;
  childCount: number;
  zIndex: number;
}
