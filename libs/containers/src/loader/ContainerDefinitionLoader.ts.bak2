/**
 * Container Definition Loader
 * Loads container definitions from container-library directory
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import { ContainerDefV2 } from '../engine/types.js';

// Get the directory name using import.meta.url
const __filename = "libs/containers/src/loader/ContainerDefinitionLoader.ts";
const __dirname = path.dirname(__filename);

export class ContainerDefinitionLoader {
  /**
   * Load all container definitions from a specific path
   */
  static async loadFromPath(dirPath: string): Promise<ContainerDefV2[]> {
    const containers: ContainerDefV2[] = [];
    
    // Check if path exists
    if (!fs.existsSync(dirPath)) {
      console.warn(`[ContainerDefinitionLoader] Path does not exist: ${dirPath}`);
      return [];
    }
    
    // Read all files in directory and subdirectories
    const files = this.getAllJsonFiles(dirPath);
    
    for (const file of files) {
      try {
        const content = fs.readFileSync(file, 'utf-8');
        const containerDef = JSON.parse(content);
        
        // Validate and convert to ContainerDefV2 format
        const convertedDef = this.convertToContainerDefV2(containerDef);
        if (convertedDef) {
          containers.push(convertedDef);
        }
      } catch (error) {
        console.error(`[ContainerDefinitionLoader] Error loading container from ${file}:`, error);
      }
    }
    
    return containers;
  }

  /**
   * Load container definitions for a specific website
   */
  static async loadForWebsite(website: string): Promise<ContainerDefV2[]> {
    const containerLibraryPath = path.join(__dirname, '..', '..', '..', '..', 'container-library');
    const websitePath = path.join(containerLibraryPath, website);
    
    return this.loadFromPath(websitePath);
  }

  /**
   * Get all JSON files recursively from a directory
   */
  private static getAllJsonFiles(dir: string): string[] {
    const results: string[] = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        // Recursively get files from subdirectories
        results.push(...this.getAllJsonFiles(fullPath));
      } else if (item.endsWith('.json')) {
        // Only include JSON files
        results.push(fullPath);
      }
    }
    
    return results;
  }

  /**
   * Convert a raw JSON object to ContainerDefV2 format
   */
  private static convertToContainerDefV2(raw: any): ContainerDefV2 | null {
    try {
      // Basic validation
      if (!raw.id) {
        console.warn('[ContainerDefinitionLoader] Container definition missing id:', raw);
        return null;
      }
      
      // Map the fields from raw JSON to ContainerDefV2 interface
      const containerDef: ContainerDefV2 = {
        id: raw.id,
        name: raw.name,
        type: raw.type,
        scope: raw.scope,
        pagePatterns: raw.page_patterns || raw.pagePatterns,
        selectors: this.convertSelectors(raw.selectors || raw.selector),
        children: raw.children,
        dependsOn: raw.dependsOn,
        capabilities: raw.capabilities || [],
        runMode: raw.runMode,
        operations: this.convertOperations(raw.operations),
        pagination: raw.pagination,
        version: raw.version,
        replacedBy: raw.replacedBy,
        reliability: raw.reliability,
        anchors: raw.anchors ? this.convertSelectors(raw.anchors) : undefined
      };
      
      // Set default selectors if none exist
      if (!containerDef.selectors || containerDef.selectors.length === 0) {
        // Try to create selectors from CSS field if available
        if (raw.css || raw.selector) {
          containerDef.selectors = [{
            classes: this.extractClasses(raw.css || raw.selector),
            variant: 'primary',
            score: 1.0
          }];
        }
      }
      
      return containerDef;
    } catch (error) {
      console.error('[ContainerDefinitionLoader] Error converting container definition:', error);
      return null;
    }
  }

  /**
   * Convert raw selectors to SelectorByClass format
   */
  private static convertSelectors(rawSelectors: any): any[] {
    if (!rawSelectors) return [];
    
    if (Array.isArray(rawSelectors)) {
      return rawSelectors.map(selector => {
        if (typeof selector === 'string') {
          // Convert string selector to object format
          return {
            classes: this.extractClasses(selector),
            variant: 'primary',
            score: 1.0
          };
        } else if (typeof selector === 'object') {
          // Already in object format, normalize it
          return {
            classes: selector.classes || this.extractClasses(selector.css || selector.selector),
            variant: selector.variant || 'primary',
            score: selector.score || 1.0
          };
        }
        return null;
      }).filter(Boolean);
    } else if (typeof rawSelectors === 'object') {
      // Single selector object
      return [{
        classes: rawSelectors.classes || this.extractClasses(rawSelectors.css || rawSelectors.selector),
        variant: rawSelectors.variant || 'primary',
        score: rawSelectors.score || 1.0
      }];
    }
    
    return [];
  }

  /**
   * Extract classes from a CSS selector
   */
  private static extractClasses(cssSelector: string): string[] {
    if (!cssSelector) return [];
    
    // Extract class names from CSS selector
    const classMatches = cssSelector.match(/\.([a-zA-Z0-9_-]+)/g);
    if (!classMatches) return [];
    
    return classMatches.map(cls => cls.substring(1)); // Remove the leading dot
  }

  /**
   * Convert raw operations to OperationDef format
   */
  private static convertOperations(rawOperations: any): any[] {
    if (!rawOperations) return [];
    
    if (!Array.isArray(rawOperations)) {
      return [];
    }
    
    return rawOperations.map(op => ({
      type: op.type,
      config: op.config
    }));
  }
}

// Export for convenience
export default ContainerDefinitionLoader;
