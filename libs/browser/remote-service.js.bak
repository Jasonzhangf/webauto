/**
 * 浏览器远程控制服务（HTTP + SSE）
 * - 默认端口可通过 env PORT_BROWSER 或传参覆盖
 * - 提供基本命令：start, newPage, goto, getCookies, saveCookies, loadCookies, getStatus, switchControl, close
 * - 提供 /events SSE 事件流，推送浏览器状态变化
 */

import http from 'http';
import { BrowserManager } from './browser-manager.js';
import { loadBrowserServiceConfig } from './browser-service-config.js';

const clients = new Set();
const manager = BrowserManager.getInstance();

function sendEvent(event, data) {
    const payload = `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
    for (const res of clients) {
        try { res.write(payload); } catch (_) {}
    }
}

function json(res, status, body) {
    const data = JSON.stringify(body);
    res.writeHead(status, {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(data)
    });
    res.end(data);
}

async function handleCommand(req, res) {
    let raw = '';
    req.on('data', chunk => { raw += chunk; });
    req.on('end', async () => {
        try {
            const { action, args = {} } = raw ? JSON.parse(raw) : { action: null, args: {} };
            if (!action) return json(res, 400, { error: 'missing action' });

            switch (action) {
                case 'start': {
                    const { headless = false, profileId = 'default', persistSession = true } = args;
                    const browser = await manager.startBrowser({ profileId, persistSession }, { headless });
                    sendEvent('browser:started', { profileId, headless });
                    return json(res, 200, { ok: true, status: manager.getStatus() });
                }
                case 'newPage': {
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const page = await browser.newPage();
                    const id = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
                    page.__id = id;
                    sendEvent('page:created', { id });
                    return json(res, 200, { ok: true, id });
                }
                case 'goto': {
                    const { url, waitTime = 3, keepOpen = false } = args;
                    if (!url) return json(res, 400, { error: 'url required' });
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const page = await browser.newPage();
                    await browser.goto(url, page, waitTime);
                    const info = await browser.getPageInfo(page);
                    sendEvent('page:navigated', { url, title: info.title });
                    if (!keepOpen) {
                        await page.close();
                        // 保存会话状态（如果启用）
                        if (browser.config.persistSession) {
                            try {
                                await browser._saveStorageState();
                            } catch (e) {
                                // 忽略保存错误
                            }
                        }
                    } else {
                        try { await page.bringToFront(); } catch {}
                    }
                    return json(res, 200, { ok: true, info });
                }
                case 'getCookies': {
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const cookies = await browser.getCookies();
                    return json(res, 200, { ok: true, count: cookies.length, cookies });
                }
                case 'saveCookies': {
                    const { path } = args;
                    if (!path) return json(res, 400, { error: 'path required' });
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const ok = await browser.saveCookies(path);
                    sendEvent('cookies:saved', { path });
                    return json(res, 200, { ok });
                }
                case 'loadCookies': {
                    const { path } = args;
                    if (!path) return json(res, 400, { error: 'path required' });
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const ok = await browser.loadCookies(path);
                    sendEvent('cookies:loaded', { path });
                    return json(res, 200, { ok });
                }
                case 'getStatus': {
                    return json(res, 200, { ok: true, status: manager.getStatus() });
                }
                case 'switchControl': {
                    const { mode } = args; // 'user' | 'remote'
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    browser.setControlMode(mode);
                    sendEvent('control:mode', { mode });
                    return json(res, 200, { ok: true, mode });
                }
                case 'screenshot': {
                    const { fullPage = true } = args;
                    const browser = manager.getBrowser();
                    if (!browser.isStarted()) await browser.start();
                    const page = await browser.newPage();
                    try {
                        const buf = await page.screenshot({ fullPage, type: 'png' });
                        const base64 = `data:image/png;base64,${buf.toString('base64')}`;
                        await page.close();
                        return json(res, 200, { ok: true, image: base64, timestamp: Date.now() });
                    } catch (e) {
                        await page.close();
                        return json(res, 500, { error: e.message });
                    }
                }
                default:
                    return json(res, 400, { error: `unknown action: ${action}` });
            }
        } catch (e) {
            return json(res, 500, { error: e.message });
        }
    });
}

export function startBrowserService(options = {}) {
    const cfg = loadBrowserServiceConfig();
    const listenPort = Number(options.port || process.env.PORT_BROWSER || cfg.port || 7704);
    const listenHost = String(options.host || cfg.host || '0.0.0.0');

    const server = http.createServer(async (req, res) => {
        const { pathname } = new URL(req.url, `http://${req.headers.host}`);
        
        // CORS headers
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
        
        if (req.method === 'OPTIONS') {
            res.writeHead(200);
            return res.end();
        }
        
        if (pathname === '/health') {
            const status = manager.getStatus();
            status.engine = manager.getBrowser()?.engineInfo || { name: 'camoufox', executablePath: null };
            return json(res, 200, { ok: true, status });
        }
        
        if (pathname === '/events') {
            res.writeHead(200, {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
            });
            clients.add(res);
            res.on('close', () => clients.delete(res));
            
            // 初始事件
            sendEvent('service:connected', { time: Date.now() });
            return;
        }

        if (req.method === 'POST' && pathname === '/command') {
            return handleCommand(req, res);
        }

        return json(res, 404, { error: 'not found' });
    });

    server.listen(listenPort, listenHost);
    return { server, port: listenPort, host: listenHost };
}

// 直接运行文件则启动服务（支持 CLI 覆盖）
if (import.meta.url === `file://${process.argv[1]}`) {
    const args = process.argv.slice(2);
    const idxPort = args.indexOf('--port');
    const idxHost = args.indexOf('--host');
    const cli = {};
    if (idxPort !== -1) cli.port = Number(args[idxPort + 1]);
    if (idxHost !== -1) cli.host = String(args[idxHost + 1]);
    const { port, host } = startBrowserService(cli);
    // 输出简单提示
    console.log(`Browser service listening on http://${host}:${port}`);
}
